<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>C programming language pearls C 语言的一些笔记 · 无辜者公墓</title><meta name="description" content="这里写一些 C 语言相关的小知识. 比较冷门. 有一些是 C 语言和 C++ 共享的, 一些不是. 第一条常识: C 和 C++ 之间的区别很大, 它们不是同一种语言. 最重要的区别是 ABI 上的区别, C++ 的名字修饰和 C 很不一样(似乎 C 就根本没有名字修饰, 所以 ABI 就是底层操作"><meta name="og:description" content="这里写一些 C 语言相关的小知识. 比较冷门. 有一些是 C 语言和 C++ 共享的, 一些不是. 第一条常识: C 和 C++ 之间的区别很大, 它们不是同一种语言. 最重要的区别是 ABI 上的区别, C++ 的名字修饰和 C 很不一样(似乎 C 就根本没有名字修饰, 所以 ABI 就是底层操作"><meta name="twitter:site" content="无辜者公墓"><meta name="twitter:title" content="C programming language pearls C 语言的一些笔记"><meta name="twitter:card" content="summary"><meta name="keywords" content="blog"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div class="container" id="stage"><div class="row"><div class="col-sm-3 col-xs-12 side-container invisible" id="side-bar"><div class="vertical-text site-title"><h3 class="site-title-small" tabindex="-1"><a class="a-title" href="/"></a></h3><h1 class="site-title-large" tabindex="-1"><a class="a-title" href="/">无辜者公墓</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div class="site-title-links" id="site-nav"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/categories">Categories</a></li><li><a href="/tags">Tags</a></li><li class="soc"><a href="https://github.com/Wang-Ji20" target="_blank" rel="noopener noreferrer" aria-label="Github"><i class="fa fa-github">&nbsp;</i></a><a href="http://Wang-Ji20.github.io/atom.xml" target="_blank" rel="noopener noreferrer" aria-label="RSS"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2023&nbsp;<a target="_blank" href="http://Wang-Ji20.github.io" rel="noopener noreferrer">Ji Wang</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div class="col-sm-9 col-xs-12 main-container invisible" id="main-container"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>C programming language pearls C 语言的一些笔记</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2023-09-02</span><span class="meta-item"><i class="fa fa-comment-o"></i><span>&nbsp;</span><a href="/2023/09/02/C-programming-language-pearls/#comments">Comments</a></span><span class="meta-item"><i class="fa fa-folder"></i><span>&nbsp;</span><a class="a-tag" href="/categories/CS/" title="CS">CS</a><span>&nbsp;</span></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a class="a-tag" href="/tags/programming/" title="programming">programming</a><span>&nbsp;</span><a class="a-tag" href="/tags/C/" title="C">C</a><span>&nbsp;</span></span></p><p class="post-abstract"><p>这里写一些 C 语言相关的小知识. 比较冷门. 有一些是 C 语言和 C++ 共享的, 一些不是. 第一条常识: C 和 C++ 之间的区别很大, 它们不是同一种语言. 最重要的区别是 ABI 上的区别, C++ 的名字修饰和 C 很不一样(似乎 C 就根本没有名字修饰, 所以 ABI 就是底层操作系统&#x2F;硬件的 ABI).</p>
<h2 id="memmove"><a href="#memmove" class="headerlink" title="memmove()"></a><code>memmove()</code></h2><p><code>ANSI</code> 定义了两个拷贝内存的函数, 分别是 <code>memcpy()</code> 和 <code>memmove()</code>. 区别是 <code>memcpy()</code> 不能处理重叠的内存区域, 而 <code>memmove()</code> 可以. 但是 <code>memmove()</code> 的实现比 <code>memcpy()</code> 要慢.</p>
<p>只应该使用 <code>memmove()</code>. 假装只有这一个函数. [1]</p>
<h2 id="VLA"><a href="#VLA" class="headerlink" title="VLA"></a>VLA</h2><p><code>VLA</code> 是 <code>Variable Length Array</code> 的缩写. <code>C99</code> 引入了这个特性. 这个特性允许我们写出这样的代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">some_function</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[n];</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看上去有些令人诧异. 按道理说, 声明动态数组都在堆上, 怎么能这样就声明一个动态数组呢? 其实, 本来栈上就可以动态分配内存的, 我们不用栈只是因为它太小了. 从汇编的角度考虑, 栈分配内存无非就是让 <code>%rsp</code> 往下移动一些字节, 这些字节的数量可以是立即数, 当然也可以是一个变量. <code>Linux</code> 中提供了一个系统调用 <code>alloca()</code> 来实现在栈上分配动态内存. 可以调那个来在栈上分配内存.</p>
<p>另外, 我们不熟悉这种写法还有一个原因, 就是 <code>C++</code> 不支持这种写法. 因为在 <code>C</code> 引入这个特性的时候, <code>C++</code> 已经有很多特性依赖于固定长度数组, 所以不太可能兼容 <code>C</code> 的这个特性.</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1887097/why-arent-variable-length-arrays-part-of-the-c-standard">许多人</a>认为这<a href="(https://nullprogram.com/blog/2019/10/27/)">不是</a>一个好写法. <code>Bjarne Stroustrup</code> 本人也提出了<a target="_blank" rel="noopener" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf">替代方案</a>.</p>
<h2 id="restrict"><a href="#restrict" class="headerlink" title="restrict"></a><code>restrict</code></h2><p>这又是一个在 <code>C++</code> 里没有的关键字, 但这个关键字在 C 语言的很多地方都可以看到, 例如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">long</span> <span class="type">int</span> <span class="title function_">strtol</span> <span class="params">(<span class="type">const</span> <span class="type">char</span> *__restrict __nptr,</span></span><br><span class="line"><span class="params">			<span class="type">char</span> **__restrict __endptr, <span class="type">int</span> __base)</span></span><br><span class="line">     __THROW __<span class="title function_">nonnull</span> <span class="params">((<span class="number">1</span>))</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个关键字告诉编译器, 这个指针是唯一指向这个内存区域的指针. 也就是说, 不存在指针别名的情况, 因此编译器可以利用这个信息生成更快的代码. 不过, 作为程序员来说, 我认为一生可能都用不到这个关键字就是了.</p>
<h2 id="const-修饰谁"><a href="#const-修饰谁" class="headerlink" title="const 修饰谁?"></a><code>const</code> 修饰谁?</h2><p>通常来说, <code>const</code> 修饰左边的东西. 左边没有的时候, 修饰右边的东西. 比如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p;</span><br></pre></td></tr></table></figure>

<p>这里 <code>const</code> 修饰的是 <code>int</code>, 所以意味着这个地方的值不会改变. 但是 <code>p</code> 这个指针可以指向别的地方. 这个指针自己是可以改变的.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> * <span class="type">const</span> p;</span><br></pre></td></tr></table></figure>

<p>这里 <code>const</code> 修饰的是指针. 所以这个指针不可以指向别的地方. 但是这个指针指向的地方的值是可以改变的.</p>
<h2 id="柔性数组"><a href="#柔性数组" class="headerlink" title="柔性数组"></a>柔性数组</h2><p>我们可以在结构体中声明一个 0 长度的数组, 像这样:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">int</span> signal[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> bbb;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个 <code>signal</code> 完全不会占用任何空间. 它只是一个占位符. 但我们可以访问它, 可以知道它的地址, 甚至还可以用下标来访问后面的 <code>bbb</code>. 这可以用来标注结构体中一些特殊的位置.</p>
<p>如果我们把这样的元素放到最后, 我们就有了一个柔性的数组. 在 <code>malloc()</code> 的时候给 <code>foo</code> 结构体多于 <code>sizeof(foo)</code> 的内存, 这些内存就可以用最后的指针来访问了.</p>
<h2 id="数组和指针"><a href="#数组和指针" class="headerlink" title="数组和指针"></a>数组和指针</h2><p>数组不是指针, 它们的大小都不同. 不过, 数组和指针可以隐式地相互转换. 这种转换带来了许多一眼看上去奇怪的代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>[a]; <span class="comment">// b = a[2] = *(2 + a) = *(a + 2)</span></span><br></pre></td></tr></table></figure>

<p>一个应用是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="comment">// &quot;\n&quot; == &#123;&#x27;\n&#x27;, &#x27;\0&#x27;&#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// case i == n - 1 of 1  -&gt; &#x27;\0&#x27;</span></span><br><span class="line">    <span class="comment">//                    0  -&gt; &#x27;\n&#x27;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, i, <span class="string">&quot;\n&quot;</span>[i == n - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="结构体赋值指定域"><a href="#结构体赋值指定域" class="headerlink" title="结构体赋值指定域"></a>结构体赋值指定域</h2><p>良好的习惯: 给结构体赋值的时候指定域. 例如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo</span> <span class="title">f</span> =</span> &#123;</span><br><span class="line">    .a = <span class="number">1</span>,</span><br><span class="line">    .b = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="数组赋值的扩展-Designated-Initializers"><a href="#数组赋值的扩展-Designated-Initializers" class="headerlink" title="数组赋值的扩展 Designated Initializers"></a>数组赋值的扩展 Designated Initializers</h2><p>数组赋值的时候, 可以指定某些位置的值. 例如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">someenum</span> &#123;</span></span><br><span class="line">    APPLE = <span class="number">1</span>,</span><br><span class="line">    BANANA = <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>] = &#123;[APPLE] = <span class="number">1</span>, [BANANA] = <span class="number">2</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>同时大部分编译器还允许 <code>...</code>, 也就是可以这样写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> widths[] = &#123; [<span class="number">0</span> ... <span class="number">9</span>] = <span class="number">1</span>, [<span class="number">10</span> ... <span class="number">99</span>] = <span class="number">2</span>, [<span class="number">100</span>] = <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>这个例子来自 [2].</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <em>The Practice of Programming. Brian W. Kernighan, Rob Pike.</em> Addison-Wesley. 1999.</p>
<p>[2] <a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html">gcc docs</a></p>
</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></span><span class="soc"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></span><span class="soc"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=http://Wang-Ji20.github.io/2023/09/02/C-programming-language-pearls/%20无辜者公墓%20C programming language pearls C 语言的一些笔记"></a></span></div><div class="pagination"><p class="clearfix"><span class="pre pagbuttons"><a role="navigation" href="/2023/09/03/Type-Trait/" title="Type Trait 类型特质"><i class="fa fa-angle-double-left"></i>&nbsp;Previous post: Type Trait 类型特质</a></span><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2023/08/29/C-Test/" title="C++ Test">Next post: C++ Test&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div><a id="comments"></a><div id="disqus_thread"></div><script>var disqus_shortname = 'wangjiblogs';
var disqus_identifier = '2023/09/02/C-programming-language-pearls/';
var disqus_title = 'C programming language pearls C 语言的一些笔记';
var disqus_url = 'http://Wang-Ji20.github.io/2023/09/02/C-programming-language-pearls/';
(function () {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async></script></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2023&nbsp;<a target="_blank" href="http://Wang-Ji20.github.io" rel="noopener noreferrer">Ji Wang</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>