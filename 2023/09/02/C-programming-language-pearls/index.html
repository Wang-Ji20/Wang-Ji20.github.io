<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/mdb-ui-kit/6.4.1/mdb.min.css" rel="stylesheet" />
    
<link rel="stylesheet" href="/css/intellij-light.css">


        <script type="text/javascript"
            src="https://cdnjs.cloudflare.com/ajax/libs/mdb-ui-kit/6.4.1/mdb.min.js"></script>
        
<link rel="stylesheet" href="/css/style.css">


            <link rel="stylesheet"
                href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />

            <style>
                .material-symbols-outlined {
                    font-variation-settings:
                        'FILL' 0,
                        'wght' 400,
                        'GRAD' 0,
                        'opsz' 24
                }
            </style>

<meta name="generator" content="Hexo 7.0.0-rc2"><link rel="alternate" href="/atom.xml" title="无辜者公墓" type="application/atom+xml">
</head>

<body>
    <div class="flex flex-row-l">
    <div class="sidebar flex flex-column flex-center wide-only" style="position: fixed; padding-top: 3em; max-width: 300px">
        <h4>Table of Contents</h4>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#memmove"><span class="toc-text">memmove()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VLA"><span class="toc-text">VLA</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#restrict"><span class="toc-text">restrict</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const-%E4%BF%AE%E9%A5%B0%E8%B0%81"><span class="toc-text">const 修饰谁?</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%94%E6%80%A7%E6%95%B0%E7%BB%84"><span class="toc-text">柔性数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E6%8C%87%E9%92%88"><span class="toc-text">数组和指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E8%B5%8B%E5%80%BC%E6%8C%87%E5%AE%9A%E5%9F%9F"><span class="toc-text">结构体赋值指定域</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E8%B5%8B%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95-Designated-Initializers"><span class="toc-text">数组赋值的扩展 Designated Initializers</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">参考资料</span></a></li></ol>
            <a href="/menu.html">[posts]</a>
    </div>

    <div class="post">
        <nav style="padding-top: 10px; position:fixed; width: 100vw; max-width: 900px; background-color:white;">
            <div class="flex flex-row-l">
                <a href="/index.html" style="color: black; padding-left:20px">
                    <span class="material-symbols-outlined" style="font-size: 20px;">
                        home
                    </span>
                </a>
                <p class="decorate-font">
                    cemetery of innocents
                </p>
                <a href="" style="color: black; padding-right: 20px">
                    <span class="material-symbols-outlined" style="font-size: 20px;">
                        toc
                    </span>
                </a>
            </div>
            <hr style="margin: 0;">
        </nav>
        <div style="height: 70px;">
        </div>

        <div style="margin: 0 0 25px 5px;">
            <h1>
                C programming pearls
            </h1>
            <p class="tldr" style="margin: 0;">
                September 2, 2023
            </p>
            
                <span class="badge badge-primary badge-primary">
                    <a href="/categories/CS/">CS</a>
                </span>
                
            
                <span class="badge rounded-pill badge-secondary">
                    <a href="/tags/programming/">programming</a>
                </span>
                
                <span class="badge rounded-pill badge-secondary">
                    <a href="/tags/C/">C</a>
                </span>
                
        </div>
        <p>这里写一些 C 语言相关的小知识. 因为我已经使用 C 很久了, 所以不会有特别基础的内容. 除了基础的语法语义之外, 还有可能会提到其标准库, 工具链, 运行环境(OS 相关), 设计模式, 命令式编程习语等等.</p>
<p>这里的东西有一些是 C 语言和 C++ 共享的, 一些不是. 第一条常识: C 和 C++ 之间的区别很大, 它们不是同一种语言. 最重要的区别是 ABI 上的区别, C++ 的名字修饰和 C 很不一样(似乎 C 就根本没有名字修饰, 所以 ABI 就是底层操作系统&#x2F;硬件的 ABI).</p>
<h2 id="memmove"><a href="#memmove" class="headerlink" title="memmove()"></a><code>memmove()</code></h2><p><code>ANSI</code> 定义了两个拷贝内存的函数, 分别是 <code>memcpy()</code> 和 <code>memmove()</code>. 区别是 <code>memcpy()</code> 不能处理重叠的内存区域, 而 <code>memmove()</code> 可以. 但是 <code>memmove()</code> 的实现比 <code>memcpy()</code> 要慢.</p>
<p>只应该使用 <code>memmove()</code>. 假装只有这一个函数. [1] 这是标准库的一个失败设计, 不应该让客户程序员来考虑内存别名的事情. 正确的设计是: 只有一个拷贝内存的函数, 它应该永远是对的, 但尽可能优化, 例如在内存不重叠的时候加快速度.</p>
<h2 id="VLA"><a href="#VLA" class="headerlink" title="VLA"></a>VLA</h2><p><code>VLA</code> 是 <code>Variable Length Array</code> 的缩写. <code>C99</code> 引入了这个特性. 这个特性允许我们写出这样的代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span><br><span class="hljs-title function_">some_function</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span><br>&#123;<br>    <span class="hljs-type">int</span> <span class="hljs-built_in">array</span>[n];<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看上去有些令人诧异. 按道理说, 声明动态数组都在堆上, 怎么能这样就声明一个动态数组呢? 其实, 本来栈上就可以动态分配内存的, 我们不用栈只是因为它太小了. 从汇编的角度考虑, 栈分配内存无非就是让 <code>%rsp</code> 往下移动一些字节, 这些字节的数量可以是立即数, 当然也可以是一个变量. <code>Linux</code> 中提供了一个系统调用 <code>alloca()</code> 来实现在栈上分配动态内存. 可以调那个来在栈上分配内存.</p>
<p>另外, 我们不熟悉这种写法还有一个原因, 就是 <code>C++</code> 不支持这种写法. 因为在 <code>C</code> 引入这个特性的时候, <code>C++</code> 已经有很多特性依赖于固定长度数组, 所以不太可能兼容 <code>C</code> 的这个特性.</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1887097/why-arent-variable-length-arrays-part-of-the-c-standard">许多人</a>认为这<a href="(https://nullprogram.com/blog/2019/10/27/)">不是</a>一个好写法. <code>Bjarne Stroustrup</code> 本人也提出了<a target="_blank" rel="noopener" href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3810.pdf">替代方案</a>.</p>
<h2 id="restrict"><a href="#restrict" class="headerlink" title="restrict"></a><code>restrict</code></h2><p>这又是一个在 <code>C++</code> 里没有的关键字, 但这个关键字在 C 语言的很多地方都可以看到, 例如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><br><span class="hljs-keyword">extern</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title function_">strtol</span> <span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *__restrict __nptr,</span><br><span class="hljs-params">			<span class="hljs-type">char</span> **__restrict __endptr, <span class="hljs-type">int</span> __base)</span><br>     __THROW __<span class="hljs-title function_">nonnull</span> <span class="hljs-params">((<span class="hljs-number">1</span>))</span>;<br><br></code></pre></td></tr></table></figure>

<p>这个关键字告诉编译器, 这个指针是唯一指向这个内存区域的指针. 也就是说, 不存在指针别名的情况, 因此编译器可以利用这个信息生成更快的代码. 不过, 作为程序员来说, 我认为一生可能都用不到这个关键字就是了.</p>
<h2 id="const-修饰谁"><a href="#const-修饰谁" class="headerlink" title="const 修饰谁?"></a><code>const</code> 修饰谁?</h2><p>通常来说, <code>const</code> 修饰左边的东西. 左边没有的时候, 修饰右边的东西. 比如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">int</span> *p;<br></code></pre></td></tr></table></figure>

<p>这里 <code>const</code> 修饰的是 <code>int</code>, 所以意味着这个地方的值不会改变. 但是 <code>p</code> 这个指针可以指向别的地方. 这个指针自己是可以改变的.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> * <span class="hljs-type">const</span> p;<br></code></pre></td></tr></table></figure>

<p>这里 <code>const</code> 修饰的是指针. 所以这个指针不可以指向别的地方. 但是这个指针指向的地方的值是可以改变的.</p>
<h2 id="柔性数组"><a href="#柔性数组" class="headerlink" title="柔性数组"></a>柔性数组</h2><p>我们可以在结构体中声明一个 0 长度的数组, 像这样:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">foo</span> &#123;</span><br>    <span class="hljs-type">int</span> len;<br>    <span class="hljs-type">int</span> signal[<span class="hljs-number">0</span>];<br>    <span class="hljs-type">int</span> bbb;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这个 <code>signal</code> 完全不会占用任何空间. 它只是一个占位符. 但我们可以访问它, 可以知道它的地址, 甚至还可以用下标来访问后面的 <code>bbb</code>. 这可以用来标注结构体中一些特殊的位置.</p>
<p>如果我们把这样的元素放到最后, 我们就有了一个柔性的数组. 在 <code>malloc()</code> 的时候给 <code>foo</code> 结构体多于 <code>sizeof(foo)</code> 的内存, 这些内存就可以用最后的指针来访问了.</p>
<h2 id="数组和指针"><a href="#数组和指针" class="headerlink" title="数组和指针"></a>数组和指针</h2><p>数组不是指针, 它们的大小都不同. 不过, 数组和指针可以隐式地相互转换. 这种转换带来了许多一眼看上去奇怪的代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">int</span> b = <span class="hljs-number">2</span>[a]; <span class="hljs-comment">// b = a[2] = *(2 + a) = *(a + 2)</span><br></code></pre></td></tr></table></figure>

<p>一个应用是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>    <span class="hljs-comment">// &quot;\n&quot; == &#123;&#x27;\n&#x27;, &#x27;\0&#x27;&#125;</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-comment">// case i == n - 1 of 1  -&gt; &#x27;\0&#x27;</span><br>    <span class="hljs-comment">//                    0  -&gt; &#x27;\n&#x27;</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d%c&quot;</span>, i, <span class="hljs-string">&quot;\n&quot;</span>[i == n - <span class="hljs-number">1</span>]);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="结构体赋值指定域"><a href="#结构体赋值指定域" class="headerlink" title="结构体赋值指定域"></a>结构体赋值指定域</h2><p>良好的习惯: 给结构体赋值的时候指定域. 例如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">foo</span> &#123;</span><br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">int</span> b;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">foo</span> <span class="hljs-title">f</span> =</span> &#123;<br>    .a = <span class="hljs-number">1</span>,<br>    .b = <span class="hljs-number">2</span>,<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="数组赋值的扩展-Designated-Initializers"><a href="#数组赋值的扩展-Designated-Initializers" class="headerlink" title="数组赋值的扩展 Designated Initializers"></a>数组赋值的扩展 Designated Initializers</h2><p>数组赋值的时候, 可以指定某些位置的值. 例如:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">someenum</span> &#123;</span><br>    APPLE = <span class="hljs-number">1</span>,<br>    BANANA = <span class="hljs-number">2</span>,<br>&#125;<br><br><span class="hljs-type">int</span> a[<span class="hljs-number">10</span>] = &#123;[APPLE] = <span class="hljs-number">1</span>, [BANANA] = <span class="hljs-number">2</span>&#125;;<br></code></pre></td></tr></table></figure>

<p>同时大部分编译器还允许 <code>...</code>, 也就是可以这样写</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> widths[] = &#123; [<span class="hljs-number">0</span> ... <span class="hljs-number">9</span>] = <span class="hljs-number">1</span>, [<span class="hljs-number">10</span> ... <span class="hljs-number">99</span>] = <span class="hljs-number">2</span>, [<span class="hljs-number">100</span>] = <span class="hljs-number">3</span> &#125;;<br></code></pre></td></tr></table></figure>

<p>这个例子来自 [2].</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <em>The Practice of Programming. Brian W. Kernighan, Rob Pike.</em> Addison-Wesley. 1999.</p>
<p>[2] <a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html">gcc docs</a></p>

    </div>

</div>

</body>

</html>
