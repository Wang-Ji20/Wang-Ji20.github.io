<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/mdb-ui-kit/6.4.1/mdb.min.css" rel="stylesheet" />
    
<link rel="stylesheet" href="/css/intellij-light.css">


        <script type="text/javascript"
            src="https://cdnjs.cloudflare.com/ajax/libs/mdb-ui-kit/6.4.1/mdb.min.js"></script>
        
<link rel="stylesheet" href="/css/style.css">


            <link rel="stylesheet"
                href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />

            <style>
                .material-symbols-outlined {
                    font-variation-settings:
                        'FILL' 0,
                        'wght' 400,
                        'GRAD' 0,
                        'opsz' 24
                }
            </style>

<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="无辜者公墓" type="application/atom+xml">
</head>

<body>
    <h1>
    Type Trait
</h1>

<p>
    <p>在模板元编程中, 我们常常要储存一些元信息. 例如类型 <code>T</code> 是否是整数, 类型 <code>T</code> 是否为指针等等. 这些信息存储在类型特质(type_trait)中.</p>
<p>为了方便理解, 我要用一个序列化器的例子来说明. 假设我们需要写一个序列化器, 它至少有以下两个功能:</p>
<ul>
<li>直接序列化值类型 <code>T</code></li>
<li>序列化指针 <code>T* p</code>, 相当于序列化 <code>*p</code></li>
</ul>
<p>因此, 我们写一个 <code>template &lt;typename T&gt;</code>, 要实例化的就有两种情况, 一种指针类型, 一种普通类型.</p>
<p>对这两种不同的情形要分别判断. 如何做到呢?</p>
<h2 id="模板实例化的选择"><a href="#模板实例化的选择" class="headerlink" title="模板实例化的选择"></a>模板实例化的选择</h2><p>我们需要定义一个谓词 <code>is_pointer&lt;T&gt;</code>, 用于判断类型 <code>T</code> 是否为指针类型. 我们可以这样定义:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_pointer</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> value = <span class="hljs-literal">false</span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_pointer</span>&lt;T*&gt; &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> value = <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在这里, 我们实例化 <code>is_pointer&lt;int *&gt;</code> 的时候, 会实例化出两个模板, 分别为:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_pointer</span>&lt;<span class="hljs-type">int</span> *&gt; &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> value = <span class="hljs-literal">false</span>;<br>&#125;;<br><br><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">is_pointer</span>&lt;<span class="hljs-type">int</span> *&gt; &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-keyword">constexpr</span> <span class="hljs-type">bool</span> value = <span class="hljs-literal">true</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>但是, 因为第二个实例化的模板更加准确, 所以编译器会选择第二个模板. 这样, <code>is_pointer&lt;T&gt;::value</code> 就为 <code>true</code>.<br>同时, <code>is_pointer&lt;int&gt;</code> 因为只有上面那种可能的代换结果, 所以它的 <code>is_pointer&lt;int&gt;::value</code> 为 <code>false</code>.</p>
<p><code>is_pointer</code> 就是一个类型特质. 没有什么魔法, 只不过是一个结构而已.</p>
<h2 id="简单选择实例化"><a href="#简单选择实例化" class="headerlink" title="简单选择实例化"></a>简单选择实例化</h2><p>上面的例子很容易, 因为只有两种情况, 而且是不是指针, 只要看看有没有 <code>*</code> 就知道了. 这个信息蕴涵在模板的输入参数中. 所以, 不用类型特质, 我们也可以这样写:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">serialize</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_exception</span>(<span class="hljs-string">&quot;not implemented&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">serialize</span><span class="hljs-params">(T *value)</span> </span>&#123;<br>    <span class="hljs-built_in">serialize</span>(*value);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>编译器会自己推测出应该选择哪一个实例化的模板函数.</p>
<p>但情况也许会很复杂. 例如, 我们只能序列化含有 <code>void serialize(Serializer &amp;ser)</code> 方法的类. 这个时候, 我们就需要类型特质了.</p>
<h2 id="SFINAE"><a href="#SFINAE" class="headerlink" title="SFINAE"></a>SFINAE</h2><p>试试定义这个类型特质:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> V = T&gt;<br><span class="hljs-keyword">struct</span> has_serialize_sfaine : std::false_type &#123;&#125;;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">has_serialize_sfaine</span>&lt;<br>    T,<br>    <span class="hljs-keyword">typename</span> std::enable_if&lt;<br>        std::is_same&lt;<span class="hljs-keyword">decltype</span>(T::serialize), <span class="hljs-built_in">void</span>(Serializer &amp;)&gt;::value,<br>        T&gt;::type&gt; : std::true_type &#123;&#125;;<br></code></pre></td></tr></table></figure>

<p>这个类型特质的意思是, 如果 <code>T</code> 有一个 <code>serialize</code> 方法, 并且这个方法接受一个 <code>Serializer &amp;</code> 类型的参数, 那么 <code>has_serialize&lt;T&gt;::value</code> 就为 <code>true</code>.</p>
<p>这里用到了 <code>std::enable_if</code> 和 <code>std::is_same</code> 两个模板结构. <code>std::enable_if</code> 的作用是, 如果它的第一个参数为 <code>true</code>, 那么这个结构中的 <code>type</code> 就为第二个参数, 否则, 这个结构中没有 <code>type</code> 这个成员. <code>std::is_same</code> 的作用是, 如果它的两个参数类型相同, 那么它的 <code>value</code> 就为 <code>true</code>, 否则为 <code>false</code>.</p>
<p>这样, 当 <code>T</code> 没有 <code>serialize</code> 方法的时候, 第二个模板就会实例化失败, 所以编译器会选择第一个模板. 否则, 编译器会选择第二个模板.</p>
<p>为什么可以这样做? 因为 SFAINE(替换失败不是错误). 编译器在实例化模板的时候, 会从上到下依次执行所有的模板实例化可能, 在每次执行中, 遇到编译错误就停下, 换另一个可选的模板. 一次代换失败, 编译器不会报错. 报错只在两种情况下发生:</p>
<ul>
<li>所有的模板都代换失败</li>
<li>模板都代换成功, 但是编译器发现有两个模板都可以选择, 而且没有一个更加准确</li>
</ul>
<p>所以, 我们可以通过刻意触发编译错误, 来选择模板.</p>
<h2 id="替代方案-static-assert"><a href="#替代方案-static-assert" class="headerlink" title="替代方案: static_assert"></a>替代方案: <code>static_assert</code></h2><p>我们可以用 <code>static_assert</code> 来刻意触发编译错误. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">serialize</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    <span class="hljs-built_in">static_assert</span>(has_serialize&lt;T&gt;::value, <span class="hljs-string">&quot;T does not have serialize method&quot;</span>);<br>    value.<span class="hljs-built_in">serialize</span>(*<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">serialize</span><span class="hljs-params">(T *value)</span> </span>&#123;<br>    <span class="hljs-built_in">serialize</span>(*value);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>好处是可以输出一些额外的诊断信息.</p>
<h2 id="替代方案-if-constexpr"><a href="#替代方案-if-constexpr" class="headerlink" title="替代方案: if constexpr"></a>替代方案: <code>if constexpr</code></h2><p>SFINAE 风格的代码很难写, 也不可读. 我们可以干掉它, 用 C++17 的 <code>if constexpr</code>. 它的作用是在编译期根据条件选择性的编译代码. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">serialize</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">if</span> <span class="hljs-title">constexpr</span> <span class="hljs-params">(std::is_pointer&lt;T&gt;::value)</span> </span>&#123;<br>        <span class="hljs-built_in">serialize</span>(*value);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> std::<span class="hljs-built_in">runtime_exception</span>(<span class="hljs-string">&quot;not implemented&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>这样, 当 <code>T</code> 是指针类型的时候, 编译器就会选择 <code>if</code> 语句中的代码, 否则就会选择 <code>else</code> 语句中的代码.</p>
<h2 id="最终方案-concept"><a href="#最终方案-concept" class="headerlink" title="最终方案: concept"></a>最终方案: <code>concept</code></h2><p>C++20 引入了 <code>concept</code> 的概念. 它的作用类似于一个类型特质, 但是比类型特质更加强大. 例如, 我们可以这样定义:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">concept</span> has_serialize_concept = <span class="hljs-built_in">requires</span>(T t, Serializer &amp;serializer) &#123;<br>  t.<span class="hljs-built_in">serialize</span>(serializer);<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>这样, 我们就可以在模板定义的时候指定 <code>has_serialize</code> 来要求 <code>T</code> 必须有 <code>serialize</code> 方法. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> = T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-type">has_serialize_concept_t</span> : std::false_type &#123;&#125;;<br><br><span class="hljs-keyword">template</span> &lt;has_serialize_concept T&gt;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">has_serialize_concept_t</span>&lt;T, T&gt; : std::true_type &#123;&#125;;<br><br></code></pre></td></tr></table></figure>


</p>

</body>

</html>
