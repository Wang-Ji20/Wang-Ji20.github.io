<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>Type Trait 类型特质 · 无辜者公墓</title><meta name="description" content="在模板元编程中, 我们常常要储存一些元信息. 例如类型 T 是否是整数, 类型 T 是否为指针等等. 这些信息存储在类型特质(type_trait)中.
为了方便理解, 我要用一个序列化器的例子来说明. 假设我们需要写一个序列化器, 它至少有以下两个功能:

直接序列化值类型 T
序列化指针 T* "><meta name="og:description" content="在模板元编程中, 我们常常要储存一些元信息. 例如类型 T 是否是整数, 类型 T 是否为指针等等. 这些信息存储在类型特质(type_trait)中.
为了方便理解, 我要用一个序列化器的例子来说明. 假设我们需要写一个序列化器, 它至少有以下两个功能:

直接序列化值类型 T
序列化指针 T* "><meta name="twitter:site" content="无辜者公墓"><meta name="twitter:title" content="Type Trait 类型特质"><meta name="twitter:card" content="summary"><meta name="keywords" content="blog"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/bootstrap.min.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="stylesheet" href="/css/style.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.3.0"><link rel="stylesheet" href="/css/prism.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div class="container" id="stage"><div class="row"><div class="col-sm-3 col-xs-12 side-container invisible" id="side-bar"><div class="vertical-text site-title"><h3 class="site-title-small" tabindex="-1"><a class="a-title" href="/"></a></h3><h1 class="site-title-large" tabindex="-1"><a class="a-title" href="/">无辜者公墓</a></h1><!--h6(onclick="triggerSiteNav()") Trigger--></div><br class="visible-lg visible-md visible-sm"><div class="site-title-links" id="site-nav"><ul><li><a href="/">Home</a></li><li><a href="/archives">Archive</a></li><li><a href="/categories">Categories</a></li><li><a href="/tags">Tags</a></li><li class="soc"><a href="https://github.com/Wang-Ji20" target="_blank" rel="noopener noreferrer" aria-label="Github"><i class="fa fa-github">&nbsp;</i></a><a href="http://Wang-Ji20.github.io/atom.xml" target="_blank" rel="noopener noreferrer" aria-label="RSS"><i class="fa fa-rss">&nbsp;</i></a></li></ul><div class="visible-lg visible-md visible-sm site-nav-footer"><br class="site-nav-footer-br"><footer><p>&copy;&nbsp;2023&nbsp;<a target="_blank" href="http://Wang-Ji20.github.io" rel="noopener noreferrer">Ji Wang</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div><div class="col-sm-9 col-xs-12 main-container invisible" id="main-container"><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post-container"><p class="post-title"><a>Type Trait 类型特质</a></p><p class="post-meta"><span class="date meta-item">Posted at&nbsp;2023-09-03</span><span class="meta-item"><i class="fa fa-comment-o"></i><span>&nbsp;</span><a href="/2023/09/03/Type-Trait/#comments">Comments</a></span><span class="meta-item"><i class="fa fa-folder"></i><span>&nbsp;</span><a class="a-tag" href="/categories/CS/" title="CS">CS</a><span>&nbsp;</span></span><span class="meta-item"><i class="fa fa-tag"></i><span>&nbsp;</span><a class="a-tag" href="/tags/programming/" title="programming">programming</a><span>&nbsp;</span><a class="a-tag" href="/tags/c/" title="c++">c++</a><span>&nbsp;</span></span></p><p class="post-abstract"><p>在模板元编程中, 我们常常要储存一些元信息. 例如类型 <code>T</code> 是否是整数, 类型 <code>T</code> 是否为指针等等. 这些信息存储在类型特质(type_trait)中.</p>
<p>为了方便理解, 我要用一个序列化器的例子来说明. 假设我们需要写一个序列化器, 它至少有以下两个功能:</p>
<ul>
<li>直接序列化值类型 <code>T</code></li>
<li>序列化指针 <code>T* p</code>, 相当于序列化 <code>*p</code></li>
</ul>
<p>因此, 我们写一个 <code>template &lt;typename T&gt;</code>, 要实例化的就有两种情况, 一种指针类型, 一种普通类型.</p>
<p>对这两种不同的情形要分别判断. 如何做到呢?</p>
<h2 id="模板实例化的选择"><a href="#模板实例化的选择" class="headerlink" title="模板实例化的选择"></a>模板实例化的选择</h2><p>我们需要定义一个谓词 <code>is_pointer&lt;T&gt;</code>, 用于判断类型 <code>T</code> 是否为指针类型. 我们可以这样定义:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_pointer</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_pointer</span>&lt;T*&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这里, 我们实例化 <code>is_pointer&lt;int *&gt;</code> 的时候, 会实例化出两个模板, 分别为:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_pointer</span>&lt;<span class="type">int</span> *&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">is_pointer</span>&lt;<span class="type">int</span> *&gt; &#123;</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">bool</span> value = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是, 因为第二个实例化的模板更加准确, 所以编译器会选择第二个模板. 这样, <code>is_pointer&lt;T&gt;::value</code> 就为 <code>true</code>.<br>同时, <code>is_pointer&lt;int&gt;</code> 因为只有上面那种可能的代换结果, 所以它的 <code>is_pointer&lt;int&gt;::value</code> 为 <code>false</code>.</p>
<p><code>is_pointer</code> 就是一个类型特质. 没有什么魔法, 只不过是一个结构而已.</p>
<h2 id="简单选择实例化"><a href="#简单选择实例化" class="headerlink" title="简单选择实例化"></a>简单选择实例化</h2><p>上面的例子很容易, 因为只有两种情况, 而且是不是指针, 只要看看有没有 <code>*</code> 就知道了. 这个信息蕴涵在模板的输入参数中. 所以, 不用类型特质, 我们也可以这样写:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">serialize</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_exception</span>(<span class="string">&quot;not implemented&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">serialize</span><span class="params">(T *value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">serialize</span>(*value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>编译器会自己推测出应该选择哪一个实例化的模板函数.</p>
<p>但情况也许会很复杂. 例如, 我们只能序列化含有 <code>void serialize(Serializer &amp;ser)</code> 方法的类. 这个时候, 我们就需要类型特质了.</p>
<h2 id="SFINAE"><a href="#SFINAE" class="headerlink" title="SFINAE"></a>SFINAE</h2><p>试试定义这个类型特质:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> V = T&gt;</span><br><span class="line"><span class="keyword">struct</span> has_serialize_sfaine : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has_serialize_sfaine</span>&lt;</span><br><span class="line">    T,</span><br><span class="line">    <span class="keyword">typename</span> std::enable_if&lt;</span><br><span class="line">        std::is_same&lt;<span class="keyword">decltype</span>(T::serialize), <span class="built_in">void</span>(Serializer &amp;)&gt;::value,</span><br><span class="line">        T&gt;::type&gt; : std::true_type &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>这个类型特质的意思是, 如果 <code>T</code> 有一个 <code>serialize</code> 方法, 并且这个方法接受一个 <code>Serializer &amp;</code> 类型的参数, 那么 <code>has_serialize&lt;T&gt;::value</code> 就为 <code>true</code>.</p>
<p>这里用到了 <code>std::enable_if</code> 和 <code>std::is_same</code> 两个模板结构. <code>std::enable_if</code> 的作用是, 如果它的第一个参数为 <code>true</code>, 那么这个结构中的 <code>type</code> 就为第二个参数, 否则, 这个结构中没有 <code>type</code> 这个成员. <code>std::is_same</code> 的作用是, 如果它的两个参数类型相同, 那么它的 <code>value</code> 就为 <code>true</code>, 否则为 <code>false</code>.</p>
<p>这样, 当 <code>T</code> 没有 <code>serialize</code> 方法的时候, 第二个模板就会实例化失败, 所以编译器会选择第一个模板. 否则, 编译器会选择第二个模板.</p>
<p>为什么可以这样做? 因为 SFAINE(替换失败不是错误). 编译器在实例化模板的时候, 会从上到下依次执行所有的模板实例化可能, 在每次执行中, 遇到编译错误就停下, 换另一个可选的模板. 一次代换失败, 编译器不会报错. 报错只在两种情况下发生:</p>
<ul>
<li>所有的模板都代换失败</li>
<li>模板都代换成功, 但是编译器发现有两个模板都可以选择, 而且没有一个更加准确</li>
</ul>
<p>所以, 我们可以通过刻意触发编译错误, 来选择模板.</p>
<h2 id="替代方案-static-assert"><a href="#替代方案-static-assert" class="headerlink" title="替代方案: static_assert"></a>替代方案: <code>static_assert</code></h2><p>我们可以用 <code>static_assert</code> 来刻意触发编译错误. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">serialize</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">static_assert</span>(has_serialize&lt;T&gt;::value, <span class="string">&quot;T does not have serialize method&quot;</span>);</span><br><span class="line">    value.<span class="built_in">serialize</span>(*<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">serialize</span><span class="params">(T *value)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">serialize</span>(*value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好处是可以输出一些额外的诊断信息.</p>
<h2 id="替代方案-if-constexpr"><a href="#替代方案-if-constexpr" class="headerlink" title="替代方案: if constexpr"></a>替代方案: <code>if constexpr</code></h2><p>SFINAE 风格的代码很难写, 也不可读. 我们可以干掉它, 用 C++17 的 <code>if constexpr</code>. 它的作用是在编译期根据条件选择性的编译代码. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">serialize</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(std::is_pointer&lt;T&gt;::value)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">serialize</span>(*value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">runtime_exception</span>(<span class="string">&quot;not implemented&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样, 当 <code>T</code> 是指针类型的时候, 编译器就会选择 <code>if</code> 语句中的代码, 否则就会选择 <code>else</code> 语句中的代码.</p>
<h2 id="最终方案-concept"><a href="#最终方案-concept" class="headerlink" title="最终方案: concept"></a>最终方案: <code>concept</code></h2><p>C++20 引入了 <code>concept</code> 的概念. 它的作用类似于一个类型特质, 但是比类型特质更加强大. 例如, 我们可以这样定义:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">concept</span> has_serialize_concept = <span class="built_in">requires</span>(T t, Serializer &amp;serializer) &#123;</span><br><span class="line">  t.<span class="built_in">serialize</span>(serializer);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这样, 我们就可以在模板定义的时候指定 <code>has_serialize</code> 来要求 <code>T</code> 必须有 <code>serialize</code> 方法. 例如:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> = T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="type">has_serialize_concept_t</span> : std::false_type &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;has_serialize_concept T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">has_serialize_concept_t</span>&lt;T, T&gt; : std::true_type &#123;&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</p></div><div class="share"><span>Share</span>&nbsp;<span class="soc"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></span><span class="soc"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></span><span class="soc"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=http://Wang-Ji20.github.io/2023/09/03/Type-Trait/%20无辜者公墓%20Type Trait 类型特质"></a></span></div><div class="pagination"><p class="clearfix"><span>&nbsp;</span><span class="next pagbuttons"><a role="navigation" href="/2023/09/02/C-programming-language-pearls/" title="C programming language pearls C 语言的一些笔记">Next post: C programming language pearls C 语言的一些笔记&nbsp;<i class="fa fa-angle-double-right"></i></a></span></p></div><a id="comments"></a><div id="disqus_thread"></div><script>var disqus_shortname = 'wangjiblogs';
var disqus_identifier = '2023/09/03/Type-Trait/';
var disqus_title = 'Type Trait 类型特质';
var disqus_url = 'http://Wang-Ji20.github.io/2023/09/03/Type-Trait/';
(function () {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//#{theme.disqus}.disqus.com/count.js" async></script></div></div></div><div class="visible-xs site-bottom-footer"><footer><p>&copy;&nbsp;2023&nbsp;<a target="_blank" href="http://Wang-Ji20.github.io" rel="noopener noreferrer">Ji Wang</a></p><p>Theme&nbsp;<a target="_blank" href="https://github.com/SumiMakito/hexo-theme-typography" rel="noopener noreferrer">Typography</a>&nbsp;by&nbsp;<a target="_blank" href="https://www.keep.moe" rel="noopener noreferrer">Makito</a></p><p>Proudly published with&nbsp;<a target="_blank" href="https://hexo.io" rel="noopener noreferrer">Hexo</a></p></footer></div></div></div></div><script src="/js/jquery-3.1.0.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script><script src="/js/google-analytics.js"></script><script src="/js/typography.js"></script></body></html>