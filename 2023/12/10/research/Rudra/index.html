<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/mdb-ui-kit/6.4.1/mdb.min.css" rel="stylesheet" />
    
<link rel="stylesheet" href="/css/intellij-light.css">


        <script type="text/javascript"
            src="https://cdnjs.cloudflare.com/ajax/libs/mdb-ui-kit/6.4.1/mdb.min.js"></script>
        
<link rel="stylesheet" href="/css/style.css">


            <link rel="stylesheet"
                href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />

            <style>
                .material-symbols-outlined {
                    font-variation-settings:
                        'FILL' 0,
                        'wght' 400,
                        'GRAD' 0,
                        'opsz' 24
                }
            </style>

<meta name="generator" content="Hexo 7.0.0-rc2"><link rel="alternate" href="/atom.xml" title="无辜者公墓" type="application/atom+xml">
</head>

<body>
    <div class="flex flex-row-l">
    <div class="sidebar flex flex-column flex-center wide-only" style="position: fixed; padding-top: 3em; padding-left: 3em; max-width: 300px">
        <h4>Table of Contents</h4>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BA%E6%96%87%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">论文要解决的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Rust"><span class="toc-text">Rust</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Unsafe-Rust"><span class="toc-text">Unsafe Rust</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BA%E6%96%87%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="toc-text">论文的解决方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E5%B8%B8%E8%A7%81-Bug"><span class="toc-text">三种常见 Bug</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-text">两个分析算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%951-%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%B5%81%E6%A3%80%E6%9F%A5%E5%99%A8"><span class="toc-text">算法1: 不安全的数据流检查器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%952-Send-Sync-%E6%A3%80%E6%9F%A5%E5%99%A8"><span class="toc-text">算法2: Send&#x2F;Sync 检查器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%84%E4%BC%B0"><span class="toc-text">评估</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E8%B6%B3"><span class="toc-text">不足</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E5%B7%A5%E4%BD%9C"><span class="toc-text">相关工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%B7%A5%E4%BD%9C"><span class="toc-text">进一步工作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-text">参考资料</span></a></li></ol>
            <a href="/menu.html">[posts]</a>
    </div>

    <div class="post">
        <nav style="padding-top: 10px; position:fixed; width: 100vw; max-width: 900px; background-color:white;">
            <div class="flex flex-row-l">
                <a href="/index.html" style="color: black; padding-left:20px">
                    <span class="material-symbols-outlined" style="font-size: 20px;">
                        home
                    </span>
                </a>
                <p class="decorate-font">
                    cemetery of innocents
                </p>
                <a href="" style="color: black; padding-right: 20px">
                    <span class="material-symbols-outlined" style="font-size: 20px;">
                        toc
                    </span>
                </a>
            </div>
            <hr style="margin: 0;">
        </nav>
        <div style="height: 70px;">
        </div>

        <div style="margin: 0 0 25px 5px;">
            <h1>
                Rudra
            </h1>
            <p class="tldr" style="margin: 0;">
                December 10, 2023
            </p>
            
            
        </div>
        <p>这篇文章介绍了 Rudra, 一个 Rust 编程语言的代码静态分析工具. 它可以检查代码中的内存安全错误. 它效率很高, 可以在六个小时内扫描几万个软件包. 在这个静态分析工具刚刚提出的时候, 它发现了两百多个内存安全问题, 其中许多问题都是比较难找的 Bug.</p>
<h2 id="论文要解决的问题"><a href="#论文要解决的问题" class="headerlink" title="论文要解决的问题"></a>论文要解决的问题</h2><h3 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h3><p>Rust 是一个比较新的编程语言. 为什么要使用 Rust 呢? 因为内存安全. 动态分配内存是编程中非常常见的需求. 写个动态数组就已经在堆上分配内存了. 在 C 语言中, 分配内存造成的错误比比皆是, 例如空指针错误, 释放后使用等等. 一旦发生内存错误, 程序通常就进入不可恢复的故障状态, 十分严重. 靠人工审查代码无法杜绝内存安全问题, 因为它的复杂度太高了, 不论经验多么丰富的程序员都没有办法写出完美的代码. 需要一些自动的手段来保证内存是安全的. 这方面最常用的技术是垃圾回收. 网页上的 Javascript, 人生苦短我用 Python, 还有 Java 都是垃圾回收语言. 在这些编程语言中, 运行时环境自动检查变量的生命周期, 回收不再被使用的内存. 但是垃圾回收并不是解决一切问题的灵丹妙药. 除了性能开销之外, 垃圾回收最大的问题是难以控制. 在性能比较重要的应用程序中, 例如浏览器, 数据库, 操作系统, 用户往往希望手动管理资源, 因此垃圾回收在这种情况下不是一个很好的选择. 既要内存安全, 又不要垃圾回收, 在 Rust 之前还没有这种情景的解决方案.</p>
<p>借鉴在内存管理方面的优秀工程实践, Rust 总结出几条可以自动执行的规则(所有权, 借用, 别名异或可变), 交给编译器来施行. 有了这些规则, 使用 Rust 写的程序只要能通过编译, 就一定没有内存错误.</p>
<h3 id="Unsafe-Rust"><a href="#Unsafe-Rust" class="headerlink" title="Unsafe Rust"></a>Unsafe Rust</h3><p>凡事都有例外(除了这句话), Rust 也不例外. 安全的 Rust 无法应付以下几种常见的情况:</p>
<ul>
<li><p>FFI 外语言接口. 很多时候需要用 Rust 调用使用其他语言写的库. 例如和操作系统交互有时需要在 Rust 中调用 C&#x2F;C++, 那 Rust 编译器自然无法保障跨语言边界的内存安全问题.</p>
</li>
<li><p>解引用裸指针. 底层的库中常常需要解引用裸指针, 例如实现一个动态增长的数组. 数组的长度是运行时数据, 没有办法在编译期间检查数组是否越界. 所以这部分的安全性只能委派给程序员来确保.</p>
</li>
</ul>
<p>为了支持这些操作, Rust 提供了 Unsafe 功能, 在由 Unsafe 包裹的语句块中, 程序员可以解引用裸指针, 调用其他语言的函数等等. 像这样:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">num</span> = <span class="hljs-number">5</span>;<br><br><span class="hljs-keyword">let</span> <span class="hljs-variable">r1</span> = &amp;num <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-type">i32</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-variable">r2</span> = &amp;<span class="hljs-keyword">mut</span> num <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span>;<br><br><span class="hljs-keyword">unsafe</span> &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;r1 is: &#123;&#125;&quot;</span>, *r1);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;r2 is: &#123;&#125;&quot;</span>, *r2);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>unsafe 将 Rust 划分成了两个子集: Safe Rust 和 Unsafe Rust. Safe Rust 可以确保完全没有内存安全问题, 但是一切 Safe Rust 都依赖于一些 Unsafe Rust, 而编译器无法承诺 Unsafe 的安全性. 因此, Unsafe Rust 的安全问题成为整个 Rust 内存安全的瓶颈, 其安全威胁也就更大.</p>
<p>来自 GaTech 的这些研究者在这篇文章中想要解决的, 就是 Rust 在 Unsafe 语句块中的内存安全隐患.</p>
<h2 id="论文的解决方法"><a href="#论文的解决方法" class="headerlink" title="论文的解决方法"></a>论文的解决方法</h2><p>在这篇论文中, 研究者识别了 Unsafe Rust 中的三种漏洞模式, 然后提出了两种新的算法来解决它们.</p>
<h3 id="三种常见-Bug"><a href="#三种常见-Bug" class="headerlink" title="三种常见 Bug"></a>三种常见 Bug</h3><ol>
<li>Panic 安全 Bug</li>
</ol>
<p>Panic 是 Rust 中提供的一个宏, 用于在程序发生严重故障的时候直接中止程序. 其运行方式有些类似于 C++ 的异常. Panic 发生之后, 程序会一层层展开函数调用栈, 然后把控制权移交给程序的 Panic 处理器.</p>
<p>Panic 无法预测, 因此很难处理与之有关的 Bug. 程序的任何一次函数调用都有可能引发 Panic. 在 Panic 之后, 程序会从原本的执行路线离开. 原本的执行路线中也许本该执行一些 Unsafe 代码, 这些 Unsafe 代码用来确保整个函数是安全的. 但是这些代码被跳过, 因此程序会发生内存错误.</p>
<ol start="2">
<li>高阶不变式 Bug</li>
</ol>
<p>泛型函数是现代编程语言中的重要特性. 使用泛型的时候往往要限制这函数只能适用于某些类型. 例如一个泛型的 <code>print</code> 函数只能打印支持打印的类型. 但我们在使用泛型函数的时候, 有时会不经意使用那些类型不满足的条件. 例如下面这个例子:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">join</span>&lt;T&gt;(array: &amp;[T], sep: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span><br><span class="hljs-keyword">where</span> T: Convert&lt;<span class="hljs-type">str</span>&gt;<br>&#123;<br>    <span class="hljs-comment">// code that handles array.len() == 0 or 1</span><br>    <span class="hljs-comment">// ...</span><br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">len</span> = sep.<span class="hljs-title function_ invoke__">len</span>() * (array.<span class="hljs-title function_ invoke__">len</span>() - <span class="hljs-number">1</span>) + array.<span class="hljs-title function_ invoke__">iter</span>().<span class="hljs-title function_ invoke__">map</span>(|s| s.<span class="hljs-title function_ invoke__">convert</span>().<span class="hljs-title function_ invoke__">len</span>()).<span class="hljs-title function_ invoke__">sum</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">result</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">with_capacity</span>(len);<br>    <span class="hljs-keyword">unsafe</span> &#123;<br>        <span class="hljs-comment">// contains uninitialized bytes</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">buf</span> = result.<span class="hljs-title function_ invoke__">get_unchecked_mut</span>(..len);<br>        buf.<span class="hljs-title function_ invoke__">copy_and_advance</span>(array[<span class="hljs-number">0</span>].<span class="hljs-title function_ invoke__">convert</span>());<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">s</span> <span class="hljs-keyword">in</span> &amp;array[<span class="hljs-number">1</span>..] &#123;<br>            buf.<span class="hljs-title function_ invoke__">copy_and_advance</span>(sep);<br>            buf.<span class="hljs-title function_ invoke__">copy_and_advance</span>(s.<span class="hljs-title function_ invoke__">convert</span>());<br>        &#125;<br>        result.<span class="hljs-title function_ invoke__">set_len</span>(len);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这是一个类似于 Python Join 的函数, array 中的字符串会用 sep 连接起来.</p>
<p>这里只要求 T 可以转换为字符串, 但是实际上代码中做了更多的假设. 它要求 T 连续转换为字符串两次的结果一样. 通常来说这个条件都是满足的, 但不能排除一些恶意的代码两次转换为字符串的长度不同. 这样的话, 上面的这段程序在第一次调用字符串转换的函数, 获得字符串长度. 第二次调用字符串长度, 完成实际的复制. 复制的长度和分配的长度也许会不一样大, 这使代码出现内存安全问题.</p>
<ol start="3">
<li>Send&#x2F;Sync Bug</li>
</ol>
<p>Rust 用两个 trait Send 和 Sync 来处理并发安全问题. 实现 Send 的类型可以被复制到其他线程中, 实现 Sync 的类型可以被多个线程同时访问. 通常原始类型和派生类型都可以由编译器自动实现这两个 trait, 但是当涉及到同步原语(如 <code>Mutex</code>, <code>RWLock</code>)的时候, 这些 trait 的使用就会出现问题.</p>
<h3 id="两个分析算法"><a href="#两个分析算法" class="headerlink" title="两个分析算法"></a>两个分析算法</h3><p>Rudra 是一个静态分析工具. 它分析源代码的结构本身, 不需要运行原本的程序. 它分析的对象是 Rust 源代码的两个中间表示(分别为 HIR 和 MIR). Rudra 在 Rust 编译器中插入了两个新的分析流程, 运行自己的算法, 并最终生成一份报告.</p>
<h4 id="算法1-不安全的数据流检查器"><a href="#算法1-不安全的数据流检查器" class="headerlink" title="算法1: 不安全的数据流检查器"></a>算法1: 不安全的数据流检查器</h4><p>这个算法的主要思路很简单. 其核心就是寻找不可立得的泛型函数. 它遍历所有涉及不安全操作的函数基本块, 在其中寻找函数调用点. 如果在一个基本块中找到不可立得的泛型函数, 那么这个基本块被认为存在安全隐患.</p>
<p>什么叫不可立得的泛型函数呢? 以上面那段代码为例, 一个类型 T 能否转换为字符串, 在实现 join 这个泛型函数的时候是不知道的. 它依赖于用户提供的一个函数, 将类型 T 转换为字符串. 既然如此, 这个用户提供的函数就是可疑的. 所以, 如果一个不安全块中存在不可立得的函数调用, 是值得我们加倍小心的.</p>
<h4 id="算法2-Send-Sync-检查器"><a href="#算法2-Send-Sync-检查器" class="headerlink" title="算法2: Send&#x2F;Sync 检查器"></a>算法2: Send&#x2F;Sync 检查器</h4><p>这个检查器通过一些启发式来判断类型 T 的代数数据类型(ADT)所需实现的 trait.</p>
<p>它有三个启发式:</p>
<ul>
<li>如果 T 有一个 API 可以移动 T, 但是没有 API 接受 &amp;T, 那么那个 ADT 需要 T 支持 Send</li>
<li>如果 T 有一个 API 接受 &amp;T, 却没有 API 接受 T, 那么 ADT: Sync 需要 T:Sync</li>
<li>如果 T 有一个 API 接受 &amp;T, 而且有个 API 接受 T 的移动, 那么 ADT:Sync 需要 Send+Sync</li>
</ul>
<h2 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h2><ol>
<li>发现多少新 Bug</li>
</ol>
<p>Rudra 消耗资源很少, 因为不需要实际生成例子和运行代码. 所以, 研究团队在 Rust 包管理器当时所有的四万个包上都跑了一遍, 发现了 264 个未知的内存安全漏洞.</p>
<ol start="2">
<li>和其他方法的比较</li>
</ol>
<ul>
<li>fuzzing: 难以找到泛型代码的 Bug.</li>
<li>其他静态分析器: 涉及的领域不同, 无法相互替代, 可以相互补充.</li>
</ul>
<ol start="3">
<li>准确率</li>
</ol>
<p>准确率不是很高.</p>
<h2 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h2><ol>
<li><p>只能发现几类内存安全错误, 但这本来也就是没办法的事情.</p>
</li>
<li><p>假阳性很高, 高准确度模式下有 50%, 低准确度更是高达 80%.</p>
</li>
<li><p>Bug 只是被发现, 没有详细的报告, 不知道错在哪里. 需要人为甄别.</p>
</li>
</ol>
<h2 id="相关工作"><a href="#相关工作" class="headerlink" title="相关工作"></a>相关工作</h2><ol>
<li><p>Rust 的形式化方法和验证.</p>
</li>
<li><p>理解 unsafe rust.</p>
</li>
<li><p>大规模漏洞挖掘工具.</p>
</li>
</ol>
<h2 id="进一步工作"><a href="#进一步工作" class="headerlink" title="进一步工作"></a>进一步工作</h2><p>idk.</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1] <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html">The Rust Programming Language</a></p>
<p>[2] <a target="_blank" rel="noopener" href="https://dl.acm.org/doi/pdf/10.1145/3477132.3483570">RUDRA: Finding Memory Safety Bugs in Rust at the Ecosystem Scale</a></p>

    </div>

</div>

</body>


<footer style="bottom: 0;
               width: 100vw;
               background-color: #ffffff;
               border-top: 1px solid;
               padding: 0 1rem 0.7rem 1rem">
    theme cemetery made by <a href="/about.html">myself</a>.
    powered by <a target="_blank" rel="noopener" href="https://hexo.io/">hexo</a>.
</footer>


</html>
