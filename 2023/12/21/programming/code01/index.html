<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/mdb-ui-kit/6.4.1/mdb.min.css" rel="stylesheet" />
    
<link rel="stylesheet" href="/css/intellij-light.css">


        <script type="text/javascript"
            src="https://cdnjs.cloudflare.com/ajax/libs/mdb-ui-kit/6.4.1/mdb.min.js"></script>
        
<link rel="stylesheet" href="/css/style.css">


            <link rel="stylesheet"
                href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />

            <style>
                .material-symbols-outlined {
                    font-variation-settings:
                        'FILL' 0,
                        'wght' 400,
                        'GRAD' 0,
                        'opsz' 24
                }
            </style>

<meta name="generator" content="Hexo 7.0.0-rc2"><link rel="alternate" href="/atom.xml" title="无辜者公墓" type="application/atom+xml">
</head>

<body>
    <div class="site-wrapper">
        <main class="site-content">
            <div class="flex flex-row-l">
    <div class="sidebar flex flex-column flex-center wide-only" style="position: fixed; padding-top: 3em; padding-left: 3em; max-width: 300px">
        <h4>Table of Contents</h4>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spinlock-API"><span class="toc-text">Spinlock API</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Some-language-constructs"><span class="toc-text">Some language constructs</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PV-locks"><span class="toc-text">PV locks</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spinlock-and-Raw-Spinlock"><span class="toc-text">Spinlock and Raw Spinlock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Init"><span class="toc-text">Init</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Locking"><span class="toc-text">Locking</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#From-C-to-x86-Assembly"><span class="toc-text">From C to x86 Assembly</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#inlining-assemblies"><span class="toc-text">inlining assemblies</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Memory-order"><span class="toc-text">Memory order</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Locking-the-slow-path"><span class="toc-text">Locking - the slow path</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#The-quicker-slow-path"><span class="toc-text">The quicker slow path</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#The-slowest-path"><span class="toc-text">The slowest path</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclusion"><span class="toc-text">Conclusion</span></a></li></ol>
            <a href="/menu.html">[posts]</a>
    </div>

    <div class="post">
        <nav style="padding-top: 10px; position:fixed; width: 100vw; max-width: 900px; background-color:white;">
            <div class="flex flex-row-l">
                <a href="/index.html" style="color: black; padding-left:20px">
                    <span class="material-symbols-outlined" style="font-size: 20px;">
                        home
                    </span>
                </a>
                <p class="decorate-font">
                    cemetery of innocents
                </p>
                <a href="" style="color: black; padding-right: 20px">
                    <span class="material-symbols-outlined" style="font-size: 20px;">
                        toc
                    </span>
                </a>
            </div>
            <hr style="margin: 0;">
        </nav>
        <div style="height: 70px;">
        </div>

        <div style="margin: 0 0 25px 5px;">
            <h1>
                qspinlock, a spinlock in the Linux Kernel
            </h1>
            <p class="tldr" style="margin: 0;">
                December 21, 2023
            </p>
            
                <span class="badge badge-primary badge-primary">
                    <a href="/categories/CS/">CS</a>
                </span>
                
            
                <span class="badge rounded-pill badge-secondary">
                    <a href="/tags/Linux/">Linux</a>
                </span>
                
                <span class="badge rounded-pill badge-secondary">
                    <a href="/tags/Synchronization/">Synchronization</a>
                </span>
                
        </div>
        <p>Recent days(months) have seen my self-indulgent consequent 3 walkthroughs on <a target="_blank" rel="noopener" href="https://baldursgate3.game/">Baldur’s Gate 3</a>. To say I regret spending so much time on it is not accurate, as I really enjoy that game. But life goes on, so I shall quit the redemption of Bhaalspawn, and resume my inquiry to software source codes.</p>
<p>I have always wanted to read Linux. It’s said to be well-crafted and itself is such a crucial source code which powers the whole world! So let’s start.</p>
<p>To read it, I need to configure my text editor first(VSCode, in my case).</p>
<p><a target="_blank" rel="noopener" href="https://clangd.llvm.org/">Clangd</a> is my language server. It uses compiler commands database to get include-path, compile flags, etc. These information is provided by the compiler, and Clangd utilizes them to help me navigate the codebase.</p>
<p>The compiler emits the compiler commands database, so I need to build up linux first(uses <code>make</code>). Then there’s a convenient script located in <code>scripts/clang-tools/gen_compile_commands.py</code>, which helps to generate the database after building.</p>
<p>The version is <code>6.7.0 RC6</code>.</p>
<h2 id="Spinlock-API"><a href="#Spinlock-API" class="headerlink" title="Spinlock API"></a>Spinlock API</h2><p>Spinlock is a common synchronization mechanism for multi-processing systems. It prevents multiple processes from entering the same spaces, as known as the <em>critical section</em>. Related explanation can be found in generic operating system <a target="_blank" rel="noopener" href="https://pages.cs.wisc.edu/~remzi/OSTEP/threads-locks.pdf">textbooks</a>.</p>
<p>Here I choose three spinlock API in linux kernel space:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    From include/linux/spinlock.h</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> spin_lock_init(_lock)   \</span><br><span class="hljs-meta">do &#123;      \</span><br><span class="hljs-meta"> spinlock_check(_lock);   \</span><br><span class="hljs-meta"> *(_lock) = __SPIN_LOCK_UNLOCKED(_lock); \</span><br><span class="hljs-meta">&#125; while (0)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> <span class="hljs-title function_">spin_lock</span><span class="hljs-params">(<span class="hljs-type">spinlock_t</span> *lock)</span><br>&#123;<br> raw_spin_lock(&amp;lock-&gt;rlock);<br>&#125;<br><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> <span class="hljs-title function_">spin_unlock</span><span class="hljs-params">(<span class="hljs-type">spinlock_t</span> *lock)</span><br>&#123;<br> raw_spin_unlock(&amp;lock-&gt;rlock);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>They are self-contained and complete. First initiate a lock, lock it, and unlock it. That’s a whole lifetime of a lock. There are actually plenty of APIs on locking, but I will only inspect these three for the sake of simplicity.</p>
<p>There’s another macro worth mentioning:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> DEFINE_SPINLOCK(x) spinlock_t x = __SPIN_LOCK_UNLOCKED(x)</span><br></code></pre></td></tr></table></figure>

<p>That’s a shortcut for defining spinlock which marries the definition and initialization. As a language without ctors, this is kind of the only way to establish some invariant when a type is constructed.</p>
<p>We can use it like:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">static</span> <span class="hljs-title function_">DEFINE_SPINLOCK</span><span class="hljs-params">(lock)</span>;<br><br><span class="hljs-type">void</span><br><span class="hljs-title function_">some_function</span><span class="hljs-params">()</span><br>&#123;<br>    spin_lock(&amp;lock);<br>    i++;<br>    spin_unlock(&amp;lock);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Some-language-constructs"><a href="#Some-language-constructs" class="headerlink" title="Some language constructs"></a>Some language constructs</h2><p>There’s some weird keyword in the API above. They are unfamiliar because they are kernel-specific, rather than a part of C language standard. So I will briefly explain them:</p>
<ul>
<li>do … while macro</li>
</ul>
<p>That’s the statement block in macros. When we need to make our macro multi-lines, we use that kind of writing.</p>
<ul>
<li><code>__always_inline</code></li>
</ul>
<p>The kernel development group thinks the <code>inline</code> keyword in GCC is, unfortunately, <a target="_blank" rel="noopener" href="https://www.kernel.org/doc/local/inline.html">broken</a>. Because that keyword is just a suggestion to the compiler, so it won’t do what it is designed to do(i.e. inline the function). So they killed that keyword, and use <code>__always_inline</code> to force the compiler inlining the function and do nothing else.</p>
<ul>
<li>mask</li>
</ul>
<p>The mask value is generated by macros. When the <code>_Q_LOCKED_BITS == 8</code> and <code>_Q_LOCKED_OFFSET = 0</code>, the generated mask is <code>(1U &lt;&lt; 8 - 1) &lt;&lt; 0</code>, which is 0xff. To extract the related bit we use <code>(a &amp; mask)</code>, and <code>(a &amp; ~mask)</code> means bits other than the masked value.</p>
<h2 id="PV-locks"><a href="#PV-locks" class="headerlink" title="PV locks"></a>PV locks</h2><p>Linux supports virtualization natively. One <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Hypervisor">hypervisor</a> technology is <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Paravirtualization">para-virtualization</a>, which is supported by the kernel.</p>
<p>Linux has a spinlock designated to KVM, the <code>pvqspinlock</code>. I will not inspect them in that article. Virtualization belongs to a broader topic.</p>
<h2 id="Spinlock-and-Raw-Spinlock"><a href="#Spinlock-and-Raw-Spinlock" class="headerlink" title="Spinlock and Raw Spinlock"></a>Spinlock and Raw Spinlock</h2><p>The spinlock is a wrapper of raw_spinlock, which does all real works. The wrapper is used to detect and diagnose deadlocks. For locks and unlocks, the function simply forwards them to raw_spinlock. The module <code>lockdeps</code> does the deadlock detection, but due to limited scope of the article, I will not discuss them further.</p>
<p>Now we are going to see the true presence of Spinlocks. How many states should it store to support the locking algorithm?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// include/linux/spinlock_types.h</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">spinlock</span> &#123;</span><br> <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">raw_spinlock</span> <span class="hljs-title">rlock</span>;</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>   u8 __padding[LOCK_PADSIZE];<br>   <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lockdep_map</span> <span class="hljs-title">dep_map</span>;</span><br>  &#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br> &#125;;<br>&#125; <span class="hljs-type">spinlock_t</span>;<br></code></pre></td></tr></table></figure>

<p>As I said, I will ignore the <code>lockdeps</code> module, so spinlock is just the same as raw_spinlock, which unfolds as follows:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// include/asm-generic/qspinlock_types.h</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">raw_spinlock</span> &#123;</span><br> <span class="hljs-type">arch_spinlock_t</span> raw_lock;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_SPINLOCK</span><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> magic, owner_cpu;<br> <span class="hljs-type">void</span> *owner;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">lockdep_map</span> <span class="hljs-title">dep_map</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125; <span class="hljs-type">raw_spinlock_t</span>;<br></code></pre></td></tr></table></figure>

<p>Aside from debugging codes, that structure is another direct mapping of the <code>arch_spinlock_t</code> type, which unfolds further:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// include/asm-generic/qspinlock_types.h</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">qspinlock</span> &#123;</span><br> <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>  <span class="hljs-type">atomic_t</span> val;<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * By using the whole 2nd least significant byte for the</span><br><span class="hljs-comment">   * pending bit, we can allow better optimization of the lock</span><br><span class="hljs-comment">   * acquisition for the pending bit holder.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>   u8 locked;<br>   u8 pending;<br>  &#125;;<br>  <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>   u16 locked_pending;<br>   u16 tail;<br>  &#125;;<br> &#125;;<br>    <span class="hljs-comment">// omit situation for big endian machines</span><br>&#125; <span class="hljs-type">arch_spinlock_t</span>;<br></code></pre></td></tr></table></figure>

<p>It’s a four byte struct, which contains a single union. The first union member, <code>val</code> suggests that clients can only change the struct atomically. I don’t think it encodes other real useful information, so let’s look at the rest of the it.</p>
<p>Intuitively, the field <code>locked</code> says whether this spinlock is in a locked state. In that state, if another thread wants to acquire the lock, it must wait. Other variables don’t make much sense right now, so let’s look at somewhere else.</p>
<h2 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// include/linux/spinlock.h</span><br><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> spin_lock_init(_lock)   \</span><br><span class="hljs-meta">do &#123;      \</span><br><span class="hljs-meta"> spinlock_check(_lock);   \</span><br><span class="hljs-meta"> *(_lock) = __SPIN_LOCK_UNLOCKED(_lock); \</span><br><span class="hljs-meta">&#125; while (0)</span><br></code></pre></td></tr></table></figure>

<p>To initialize a spinlock, the code firstly check whether the incoming <code>_lock</code> is a pointer to a spinlock, then fill it with a spinlock in <code>unlocked</code> state.</p>
<p>Here’s a trick in weak typing <code>C</code> to ensure some type safety:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> __always_inline <span class="hljs-type">raw_spinlock_t</span> *<span class="hljs-title function_">spinlock_check</span><span class="hljs-params">(<span class="hljs-type">spinlock_t</span> *lock)</span><br>&#123;<br> <span class="hljs-keyword">return</span> &amp;lock-&gt;rlock;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>That function is not used: no one checks its return value. Maybe every compiler removes it in optimization, but that’s fine, because that function is used in compile stage, rather than runtime stage.</p>
<p>When a client gives wrong type of pointer to the function, it will generate a compiler warning(which turning out to be errors), ending the compile process. By that way it ensures the <code>_lock</code> user passes to <code>spin_lock_init()</code> is always the right type.</p>
<p>After several macro expansions, let’s see how the bookkeeper registers an initial lock state:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// include/asm-generic/qspinlock_types.h</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __ARCH_SPIN_LOCK_UNLOCKED &#123; &#123; .val = ATOMIC_INIT(0) &#125; &#125;</span><br></code></pre></td></tr></table></figure>

<p>It simply make the struct zero.</p>
<h2 id="Locking"><a href="#Locking" class="headerlink" title="Locking"></a>Locking</h2><p>The first expansion resolves to this function:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// include/linux/spinlock_api_smp.h</span><br><span class="hljs-comment">// smp means Symmetric MultiProcessors, an architecture where we have many processors but only one memory.</span><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __raw_spin_lock(<span class="hljs-type">raw_spinlock_t</span> *lock)<br>&#123;<br> preempt_disable();<br> spin_acquire(&amp;lock-&gt;dep_map, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, _RET_IP_);<br>    LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>1 During a lock acquisition, we really don’t want other threads to disturb us, otherwise this piece of code can bring out more race conditions than it tries to solve. So preempt is disabled here.</p>
<p>2 This one is used by <code>lockdeps</code> module to track deadlocks.</p>
<p>3 This macro does the real work:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// include/linux/lockdep.h</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LOCK_CONTENDED(_lock, try, lock) \</span><br><span class="hljs-meta"> lock(_lock)</span><br><br></code></pre></td></tr></table></figure>

<p>, which hints us to find <code>do_raw_spin_lock</code>, turning out to be:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title function_">do_raw_spin_lock</span><span class="hljs-params">(<span class="hljs-type">raw_spinlock_t</span> *lock)</span> __<span class="hljs-title function_">acquires</span><span class="hljs-params">(lock)</span><br>&#123;<br> __acquire(lock);<br> arch_spin_lock(&amp;lock-&gt;raw_lock);<br> mmiowb_spin_lock();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>1 This is still used by diagnoses.</p>
<p>2 does the real work.</p>
<p>3 fallback for architectures that don’t support default spinlock implementations.</p>
<p>And the real work is…</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> arch_spin_lock(l)  queued_spin_lock(l)</span><br></code></pre></td></tr></table></figure>

<p>Then we came to <code>qspinlock.h</code>.</p>
<h2 id="From-C-to-x86-Assembly"><a href="#From-C-to-x86-Assembly" class="headerlink" title="From C to x86 Assembly"></a>From C to x86 Assembly</h2><p>The definition of queued_spin_lock is quite simple; it tries to acquire the lock. If the lock is acquired by other threads, it enters a “slow path” which details the queue algorithm.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * queued_spin_lock - acquire a queued spinlock</span><br><span class="hljs-comment"> * @lock: Pointer to queued spinlock structure</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span> <span class="hljs-title function_">queued_spin_lock</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> qspinlock *lock)</span><br>&#123;<br> <span class="hljs-type">int</span> val = <span class="hljs-number">0</span>;<br><br> <span class="hljs-keyword">if</span> (likely(atomic_try_cmpxchg_acquire(&amp;lock-&gt;val, &amp;val, _Q_LOCKED_VAL)))<br>  <span class="hljs-keyword">return</span>;<br><br> queued_spin_lock_slowpath(lock, val);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>The <code>likely</code> is a compiler intrinsic optimization. By saying some branch in condition is more likely to happen, it helps the compiler arrange code to predict branch.</p>
<p>Next, I will take a closer look at <code>atomic_try_cmpxchg_acquire</code>. There’s two interesting aspects about that function: 1. <code>cmpxchg</code> is a assembly instruction, so it must be implemented by inlining assemblies. 2. <code>acquire</code> specifies a memory ordering. These two concepts will comprehend the next two sections.</p>
<h3 id="inlining-assemblies"><a href="#inlining-assemblies" class="headerlink" title="inlining assemblies"></a>inlining assemblies</h3><p>Eliminating <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Instrumentation_(computer_programming)">instrumentation</a> codes, the <code>cmpxchg</code> is the following assembly code:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// arch/x86/include/asm/cmpxchg.h</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __raw_try_cmpxchg(_ptr, _pold, _new, size, lock)  \</span><br><span class="hljs-meta">(&#123;         \</span><br><span class="hljs-meta"> bool success;       \</span><br><span class="hljs-meta"> __typeof__(_ptr) _old = (__typeof__(_ptr))(_pold);  \</span><br><span class="hljs-meta"> __typeof__(*(_ptr)) __old = *_old;    \</span><br><span class="hljs-meta"> __typeof__(*(_ptr)) __new = (_new);    \</span><br><span class="hljs-meta"> switch (size) &#123;       \</span><br><span class="hljs-meta">      \</span><br><span class="hljs-meta"> case __X86_CASE_L:      \</span><br><span class="hljs-meta"> &#123;        \</span><br><span class="hljs-meta">  volatile u32 *__ptr = (volatile u32 *)(_ptr);  \</span><br><span class="hljs-meta">  asm volatile(lock <span class="hljs-string">&quot;cmpxchgl %[new], %[ptr]&quot;</span>  \</span><br><span class="hljs-meta">        CC_SET(z)     \</span><br><span class="hljs-meta">        : CC_OUT(z) (success),   \</span><br><span class="hljs-meta">          [ptr] <span class="hljs-string">&quot;+m&quot;</span> (*__ptr),   \</span><br><span class="hljs-meta">          [old] <span class="hljs-string">&quot;+a&quot;</span> (__old)   \</span><br><span class="hljs-meta">        : [new] <span class="hljs-string">&quot;r&quot;</span> (__new)   \</span><br><span class="hljs-meta">        : <span class="hljs-string">&quot;memory&quot;</span>);    \</span><br><span class="hljs-meta">  break;       \</span><br><span class="hljs-meta"> &#125;        \</span><br><span class="hljs-meta"> default:       \</span><br><span class="hljs-meta">  __cmpxchg_wrong_size();     \</span><br><span class="hljs-meta"> &#125;        \</span><br><span class="hljs-meta"> <span class="hljs-keyword">if</span> (unlikely(!success))      \</span><br><span class="hljs-meta">  *_old = __old;      \</span><br><span class="hljs-meta"> likely(success);      \</span><br><span class="hljs-meta">&#125;)</span><br></code></pre></td></tr></table></figure>

<p>For our purpose only the 32-bit case is relevant. The function compares the value in <code>_ptr</code>, if <code>*_ptr</code> is equal to <code>*_pold</code>, then <code>*_ptr</code> is replaced by <code>_new</code>. If the replacement occurs, the function returns true, otherwise false. Worth noting that this is a valued statement block. The value of <code>(&#123;statements;&#125;)</code> is the last statement, in our case, <code>likely(success)</code>, or just <code>success</code>.</p>
<p>There’s some sanity checks. They are necessary, but I will ignore them, and dive into the asm block. Related macros are expanded and simplified if necessary.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(</span><br><span class="hljs-params">                 <span class="hljs-string">&quot;lock;&quot;</span></span><br><span class="hljs-params">                 <span class="hljs-string">&quot;cmpxchgl %[new], %[ptr]&quot;</span>  \</span><br><span class="hljs-params">        : <span class="hljs-string">&quot;=@ccz&quot;</span> (success),   \</span><br><span class="hljs-params">          [ptr] <span class="hljs-string">&quot;+m&quot;</span> (*__ptr),   \</span><br><span class="hljs-params">          [old] <span class="hljs-string">&quot;+a&quot;</span> (__old)   \</span><br><span class="hljs-params">        : [new] <span class="hljs-string">&quot;r&quot;</span> (__new)   \</span><br><span class="hljs-params">        : <span class="hljs-string">&quot;memory&quot;</span>)</span>;    \<br></code></pre></td></tr></table></figure>

<p>Asm block is scary at the first sight, so we need some patience and good <a target="_blank" rel="noopener" href="http://www.ibiblio.org/gferg/ldp/GCC-Inline-Assembly-HOWTO.html">guidance</a>.</p>
<p>The first line, <code>lock;</code>, is a instruction prefix, which means it decorates the next instruction, making it atomic, as said the <a target="_blank" rel="noopener" href="https://www.amd.com/content/dam/amd/en/documents/processor-tech-docs/programmer-references/24592.pdf">AMD manual</a>:</p>
<blockquote>
<p>The LOCK prefix causes certain read-modify-write instructions that access memory to occur atomically. The mechanism for doing so is implementation-dependent (for example, the mechanism may involve locking of data-cache lines that contain copies of the referenced memory operands, and&#x2F;or bus signaling or packet-messaging on the bus). The prefix is intended to give the processor exclusive use of shared memory operands in a multiprocessor system.</p>
</blockquote>
<p>The general structure of a asm block are like this:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">asm</span> [<span class="hljs-keyword">volatile</span>] (<br>    <span class="hljs-string">&quot;&lt;instructions separated by ; or \n\t&gt;&quot;</span><br>    : output parameters,<br>    : input parameters,<br>    : changed registers or memory<br>);<br></code></pre></td></tr></table></figure>

<p>The first part is a instruction pattern. Just like <code>printf</code>, the pattern is filled by parameters given later, after two colons. The <code>%[&lt;label&gt;]</code> pattern is reserved for the latter refilling. For example, <code>[new] &quot;r&quot; (__new)</code> specifies that the <code>__new</code> will be read to fill the position <code>%[&lt;label&gt;]</code>. Whether that value stores in memory or register is unclear to us; gcc chooses on its whim.</p>
<p>After this block, we can expect <code>success</code> to store the <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Status_register">conditional code</a> which tells us whether the exchange happened. The GCC <a target="_blank" rel="noopener" href="https://gcc.gnu.org/onlinedocs/gcc/extensions-to-the-c-language-family/how-to-use-inline-assembly-language-in-c-code.html">documentation</a> tells us:</p>
<blockquote>
<p>x86 family:<br>The flag output constraints for the x86 family are of the form &#x3D;@cc(cond) where cond is one of the standard conditions defined in the ISA manual for jcc or setcc.</p>
</blockquote>
<p>In particular, <code>z</code> means equal or <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Zero_flag">zero flag</a> set.</p>
<h3 id="Memory-order"><a href="#Memory-order" class="headerlink" title="Memory order"></a>Memory order</h3><p>On strongly-ordered systems — x86, SPARC TSO, IBM mainframe, etc. — <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering">release-acquire ordering</a> is automatic for the majority of operations.</p>
<p>We know in modern hardware, the compiler and hardware may interleave our code in unpredictable ways. To address that, we can instruct them to constraint their optimization. <a target="_blank" rel="noopener" href="https://doc.rust-lang.org/nomicon/atomics.html">The constraint</a> has four levels:</p>
<ul>
<li><p>Sequentially Consistent: Don’t reorder.</p>
</li>
<li><p>Acquire: All data accesses after me stays with it.</p>
</li>
<li><p>Release: All data accesses before me stays with it.</p>
</li>
<li><p>Relaxed: Hardware, do whatever ye wants.</p>
</li>
</ul>
<p>That’s my most imprecise and irresponsible interpretation. <a target="_blank" rel="noopener" href="https://research.swtch.com/mm">Many authors</a> have discussed them extensively, but due to the scope of the article I can say no further.</p>
<h2 id="Locking-the-slow-path"><a href="#Locking-the-slow-path" class="headerlink" title="Locking - the slow path"></a>Locking - the slow path</h2><p>Now that we know the lock is acquired by someone else, the lock is going to spin and wait until the lock is available. The Linux kernel implements a optimized <a target="_blank" rel="noopener" href="https://www.cs.rochester.edu/u/scott/papers/1991_TOCS_synch.pdf">MCS locking algorithm</a>, which added a pending bit(byte) to the lock. If the pending bit is set, it means the current lock has only one running holder before it, and the current lock is not queued. It’s only until the third competitor appears that a queue is constructed. Because that occasion is rarer, it reduces the cost of memory allocation as well as cacheline misses.</p>
<p>So this function has two execution flows: the quicker slow path, and the slower slow path.</p>
<h3 id="The-quicker-slow-path"><a href="#The-quicker-slow-path" class="headerlink" title="The quicker slow path"></a>The quicker slow path</h3><p>As we enter the slow path, the value of lock is held or the lock is claimed but didn’t finish acquiring by other threads.</p>
<p>We denote the lock state by a triple <code>(queue tail, pending bit, lock value)</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Wait for in-progress pending-&gt;locked hand-overs with a bounded</span><br><span class="hljs-comment"> * number of spins so that we guarantee forward progress.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 0,1,0 -&gt; 0,0,1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (val == _Q_PENDING_VAL) &#123;<br> <span class="hljs-type">int</span> cnt = _Q_PENDING_LOOPS;<br> val = atomic_cond_read_relaxed(&amp;lock-&gt;val,<br>           (VAL != _Q_PENDING_VAL) || !cnt--);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>(0, 0, 0)</code> is the fast path. The slow path starts with <code>(0, 1, 0)</code>, where the lock is released recently by a old owner, but the current pending lock(not me) hasn’t fully acquired it. On that case we have to wait until it acquires the lock, after which the lock enters the state <code>(0, 0, 1)</code>.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (val &amp; ~_Q_LOCKED_MASK)<br> <span class="hljs-keyword">goto</span> <span class="hljs-built_in">queue</span>;<br></code></pre></td></tr></table></figure>

<p>Then we read the lock again. We fetch the <code>pending | queue</code> tail bits. They are set if someone else is already waiting for the lock. In that condition, we know our lock is the 3rd candidate, so we must queue. That’s the slower slow path. But let’s assume our lock is the pending lock so that we can go through the quicker slow path.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">val = queued_fetch_set_pending_acquire(lock);<br></code></pre></td></tr></table></figure>

<p>That function atomically test and set the pending bit of our lock. It returns the old value in the lock. We check the old value, if the lock is unfortunately acquired by others again before, our lock has no choices but to wait again:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C"><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * If we observe contention, there is a concurrent locker.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Undo and queue; our setting of PENDING might have made the</span><br><span class="hljs-comment"> * n,0,0 -&gt; 0,0,0 transition fail and it will now be waiting</span><br><span class="hljs-comment"> * on @next to become !NULL.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (unlikely(val &amp; ~_Q_LOCKED_MASK)) &#123;<br><br> <span class="hljs-comment">/* Undo PENDING if we set it. */</span><br> <span class="hljs-keyword">if</span> (!(val &amp; _Q_PENDING_MASK))<br>  clear_pending(lock);<br><br> <span class="hljs-keyword">goto</span> <span class="hljs-built_in">queue</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>After that our lock can simply spin until the former lock owner releases the lock and takes the lock:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * We&#x27;re pending, wait for the owner to go away.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 0,1,1 -&gt; *,1,0</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * this wait loop must be a load-acquire such that we match the</span><br><span class="hljs-comment"> * store-release that clears the locked bit and create lock</span><br><span class="hljs-comment"> * sequentiality; this is because not all</span><br><span class="hljs-comment"> * clear_pending_set_locked() implementations imply full</span><br><span class="hljs-comment"> * barriers.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">if</span> (val &amp; _Q_LOCKED_MASK)<br> smp_cond_load_acquire(&amp;lock-&gt;locked, !VAL);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * take ownership and clear the pending bit.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 0,1,0 -&gt; 0,0,1</span><br><span class="hljs-comment"> */</span><br>clear_pending_set_locked(lock);<br>lockevent_inc(lock_pending);<br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * End of pending bit optimistic spinning and beginning of MCS</span><br><span class="hljs-comment"> * queuing.</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure>

<h3 id="The-slowest-path"><a href="#The-slowest-path" class="headerlink" title="The slowest path"></a>The slowest path</h3><p>When the lock is busy, the lock is arranged as a queue. The queue data structure is stored per CPU and is fixed. Here’s the definition:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><br><span class="hljs-comment">// kernel/locking/mcs_spinlock.h</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_spinlock</span> &#123;</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_spinlock</span> *<span class="hljs-title">next</span>;</span><br> <span class="hljs-type">int</span> locked; <span class="hljs-comment">/* 1 if lock acquired */</span><br> <span class="hljs-type">int</span> count;  <span class="hljs-comment">/* nesting count, see qspinlock.c */</span><br>&#125;;<br><br><span class="hljs-comment">// kernel/locking/qspinlock.c</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">qnode</span> &#123;</span><br> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mcs_spinlock</span> <span class="hljs-title">mcs</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> CONFIG_PARAVIRT_SPINLOCKS</span><br> <span class="hljs-type">long</span> reserved[<span class="hljs-number">2</span>];<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;;<br><br></code></pre></td></tr></table></figure>

<p><code>qnode</code> is a thin wrapper of <code>mcs_spinlock</code>. <code>mcs_spinlock</code> contains one pointer to the next spinlock in queue, a locked flag and a nesting count.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs C"><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_NODES 4</span><br><br><span class="hljs-type">static</span> <span class="hljs-title function_">DEFINE_PER_CPU_ALIGNED</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> qnode, qnodes[MAX_NODES])</span>;<br></code></pre></td></tr></table></figure>

<p>Every CPU has four qnodes, because there’s four conditions where the control flow in one CPU changes, namely:</p>
<ul>
<li><p>User processes: When the spin lock is acquired, the kernel interruption is disabled, leading to the end of context switching, so only one user process may acquire the lock.</p>
</li>
<li><p>Software interrupt: syscall…</p>
</li>
<li><p>Hardware interrupt: IO…</p>
</li>
<li><p>non-maskable interrupt</p>
</li>
</ul>
<p>Our lock needs to know its position in the queue:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs C">node = this_cpu_ptr(&amp;qnodes[<span class="hljs-number">0</span>].mcs);<br>idx = node-&gt;count++;<br>tail = encode_tail(smp_processor_id(), idx);<br></code></pre></td></tr></table></figure>

<p>If one CPU has given out more than four instances of locks, the qspinlock fall back to normal spinlock.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (unlikely(idx &gt;= MAX_NODES)) &#123;<br> lockevent_inc(lock_no_node);<br> <span class="hljs-keyword">while</span> (!queued_spin_trylock(lock))<br>  cpu_relax();<br> <span class="hljs-keyword">goto</span> release;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>After that, our lock get from CPU a node to enqueue.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C">node = grab_mcs_node(node, idx);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Keep counts of non-zero index values:</span><br><span class="hljs-comment"> */</span><br>lockevent_cond_inc(lock_use_node2 + idx - <span class="hljs-number">1</span>, idx);<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * Ensure that we increment the head node-&gt;count before initialising</span><br><span class="hljs-comment"> * the actual node. If the compiler is kind enough to reorder these</span><br><span class="hljs-comment"> * stores, then an IRQ could overwrite our assignments.</span><br><span class="hljs-comment"> */</span><br>barrier();<br><br>node-&gt;locked = <span class="hljs-number">0</span>;<br>node-&gt;next = <span class="hljs-literal">NULL</span>;<br>pv_init_node(node);<br></code></pre></td></tr></table></figure>

<p>It’s passed so long. During that time, the lock may have been released, so we can probe again to see whether we can grab the lock now:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">if</span> (queued_spin_trylock(lock))<br> <span class="hljs-keyword">goto</span> release;<br></code></pre></td></tr></table></figure>

<p>As our lock has gained a node to enqueue, the next thing is to actuate the enqueue.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  * Publish the updated tail.</span><br><span class="hljs-comment">  * We have already touched the queueing cacheline; don&#x27;t bother with</span><br><span class="hljs-comment">  * pending stuff.</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * p,*,* -&gt; n,*,*</span><br><span class="hljs-comment">  */</span><br> old = xchg_tail(lock, tail);<br> next = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure>

<p>We replaced the tail id by our new tail id, refetching the old tail id. That id is decoded to find qnode. We need that qnode because it’s our former lock owner. After its release, it can find us and unset our lock bit.</p>
<p>Then start waiting! The loop is inside the macro <code>arch_mcs_spin_lock_contended</code>, where ensures the node is head of queue after it.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">  * if there was a previous node; link it and wait until reaching the</span><br><span class="hljs-comment">  * head of the waitqueue.</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">if</span> (old &amp; _Q_TAIL_MASK) &#123;<br>  prev = decode_tail(old);<br><br>  <span class="hljs-comment">/* Link @node into the waitqueue. */</span><br>  WRITE_ONCE(prev-&gt;next, node);<br><br>  pv_wait_node(node, prev);<br>  arch_mcs_spin_lock_contended(&amp;node-&gt;locked);<br><br>  <span class="hljs-comment">/*</span><br><span class="hljs-comment">   * While waiting for the MCS lock, the next pointer may have</span><br><span class="hljs-comment">   * been set by another lock waiter. We optimistically load</span><br><span class="hljs-comment">   * the next pointer &amp; prefetch the cacheline for writing</span><br><span class="hljs-comment">   * to reduce latency in the upcoming MCS unlock operation.</span><br><span class="hljs-comment">   */</span><br>  next = READ_ONCE(node-&gt;next);<br>  <span class="hljs-keyword">if</span> (next)<br>   prefetchw(next);<br> &#125;<br><br><br></code></pre></td></tr></table></figure>

<p>Wait til the lock is free:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">val = atomic_cond_read_acquire(&amp;lock-&gt;val, !(VAL &amp; _Q_LOCKED_PENDING_MASK));<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C"><br>locked:<br> <span class="hljs-comment">/*</span><br><span class="hljs-comment">  * claim the lock:</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * n,0,0 -&gt; 0,0,1 : lock, uncontended</span><br><span class="hljs-comment">  * *,*,0 -&gt; *,*,1 : lock, contended</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * If the queue head is the only one in the queue (lock value == tail)</span><br><span class="hljs-comment">  * and nobody is pending, clear the tail code and grab the lock.</span><br><span class="hljs-comment">  * Otherwise, we only need to grab the lock.</span><br><span class="hljs-comment">  */</span><br><br> <span class="hljs-comment">/*</span><br><span class="hljs-comment">  * In the PV case we might already have _Q_LOCKED_VAL set, because</span><br><span class="hljs-comment">  * of lock stealing; therefore we must also allow:</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * n,0,1 -&gt; 0,0,1</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * Note: at this point: (val &amp; _Q_PENDING_MASK) == 0, because of the</span><br><span class="hljs-comment">  *       above wait condition, therefore any concurrent setting of</span><br><span class="hljs-comment">  *       PENDING will make the uncontended transition fail.</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">if</span> ((val &amp; _Q_TAIL_MASK) == tail) &#123;<br>  <span class="hljs-keyword">if</span> (atomic_try_cmpxchg_relaxed(&amp;lock-&gt;val, &amp;val, _Q_LOCKED_VAL))<br>   <span class="hljs-keyword">goto</span> release; <span class="hljs-comment">/* No contention */</span><br> &#125;<br><br> <span class="hljs-comment">/*</span><br><span class="hljs-comment">  * Either somebody is queued behind us or _Q_PENDING_VAL got set</span><br><span class="hljs-comment">  * which will then detect the remaining tail and queue behind us</span><br><span class="hljs-comment">  * ensuring we&#x27;ll see a @next.</span><br><span class="hljs-comment">  */</span><br> set_locked(lock);<br><br> <span class="hljs-comment">/*</span><br><span class="hljs-comment">  * contended path; wait for next if not observed yet, release.</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">if</span> (!next)<br>  next = smp_cond_load_relaxed(&amp;node-&gt;next, (VAL));<br><br> arch_mcs_spin_unlock_contended(&amp;next-&gt;locked);<br> pv_kick_node(lock, next);<br><br>release:<br> trace_contention_end(lock, <span class="hljs-number">0</span>);<br><br> <span class="hljs-comment">/*</span><br><span class="hljs-comment">  * release the node</span><br><span class="hljs-comment">  */</span><br> __this_cpu_dec(qnodes[<span class="hljs-number">0</span>].mcs.count);<br><br></code></pre></td></tr></table></figure>

<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>Hacking Linux is more tiring than I thought.. Maybe later articles in the series will deal with the release part. The locking part has demonstrated a heady and rigorous investigation on hardware&#x2F;software interface and tradeoff between implementation and optimization.</p>
<p>The next article will not look at so complicated code, of course.</p>

    </div>

</div>

        </main>
        <hr>
<footer class="site-footer">
    <div class="top-nav fit-content">
        © 2023-2025 Ji Wang |
        <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc/4.0/" style="padding-left: 5px;">
            Creative Commons Attribution License
        </a>
    </div>
    <div class="top-nav fit-content">
        <a target="_blank" rel="noopener" href="https://github.com/Wang-Ji20" class="footer-links"><img src="/asset/github.svg" alt="github"
                width="20" height="20"></a>
        <a href="mailto:jiwangcdi@gmail.com" class="footer-links"><img src="/asset/email.svg" alt="email" width="20"
                height="20"></a>
        <a target="_blank" rel="noopener" href="https://www.linkedin.com/in/%E9%9B%86-%E7%8E%8B-67b0b92a7/" class="footer-links"><img
                src="/asset/linkedin.svg" alt="linkedin" width="20" height="20"></a>
    </div>
</footer>

    </div>
</body>

</html>
