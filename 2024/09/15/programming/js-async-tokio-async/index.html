<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/mdb-ui-kit/6.4.1/mdb.min.css" rel="stylesheet" />
    
<link rel="stylesheet" href="/css/intellij-light.css">


        <script type="text/javascript"
            src="https://cdnjs.cloudflare.com/ajax/libs/mdb-ui-kit/6.4.1/mdb.min.js"></script>
        
<link rel="stylesheet" href="/css/style.css">


            <link rel="stylesheet"
                href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />

            <style>
                .material-symbols-outlined {
                    font-variation-settings:
                        'FILL' 0,
                        'wght' 400,
                        'GRAD' 0,
                        'opsz' 24
                }
            </style>

<meta name="generator" content="Hexo 7.0.0-rc2"><link rel="alternate" href="/atom.xml" title="无辜者公墓" type="application/atom+xml">
</head>

<body>
    <div class="site-wrapper">
        <main class="site-content">
            <div class="flex flex-row-l">
    <div class="sidebar flex flex-column flex-center wide-only" style="position: fixed; padding-top: 3em; padding-left: 3em; max-width: 300px">
        <h4>Table of Contents</h4>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JS-async-vs-Rust-async"><span class="toc-text">JS async vs Rust async</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#First-await-execution-timing"><span class="toc-text">First await execution timing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Task-spawning"><span class="toc-text">Task spawning</span></a></li></ol></li></ol>
            <a href="/menu.html">[posts]</a>
    </div>

    <div class="post">
        <nav style="padding-top: 10px; position:fixed; width: 100vw; max-width: 900px; background-color:white;">
            <div class="flex flex-row-l">
                <a href="/index.html" style="color: black; padding-left:20px">
                    <span class="material-symbols-outlined" style="font-size: 20px;">
                        home
                    </span>
                </a>
                <p class="decorate-font">
                    cemetery of innocents
                </p>
                <a href="" style="color: black; padding-right: 20px">
                    <span class="material-symbols-outlined" style="font-size: 20px;">
                        toc
                    </span>
                </a>
            </div>
            <hr style="margin: 0;">
        </nav>
        <div style="height: 70px;">
        </div>

        <div style="margin: 0 0 25px 5px;">
            <h1>
                Tokio async is lazy
            </h1>
            <p class="tldr" style="margin: 0;">
                September 15, 2024
            </p>
            
                <span class="badge badge-primary badge-primary">
                    <a href="/categories/CS/">CS</a>
                </span>
                
            
                <span class="badge rounded-pill badge-secondary">
                    <a href="/tags/programming/">programming</a>
                </span>
                
                <span class="badge rounded-pill badge-secondary">
                    <a href="/tags/Rust/">Rust</a>
                </span>
                
        </div>
        <p>Asynchronous programming is hard because its execution flow differs from the normal sequential flow. An async function doesn’t run from start to finish in one go; instead, it returns control multiple times throughout its execution. Each time it hits an await, it yields control back to its caller, which may yield control to its own caller, and so on, until control eventually returns to the runtime scheduler. The scheduler, which operates behind the scenes, saves the remaining code and runtime context between await and return points, a process that involves handling “continuations” (also referred to as tasks, futures, or promises). The scheduler polls these continuations and, when one is ready to execute, transfers control back to it, allowing the code to run until the next await is encountered.</p>
<p>Initially, the continuation pool contains only one element: the async main function. If the main function awaits other async functions without additional tasks, the code doesn’t run asynchronously in the true sense because the pool has only one continuation. This means it must wait for the main function to finish executing before anything else can happen, making it essentially equivalent to synchronous code.</p>
<p>To enable true concurrency, we need to spawn new tasks. This increases the number of tasks in the pool, giving the scheduler more options to choose from and allowing it to execute whichever task is ready at a given moment.</p>
<p>This makes async programming look somewhat similar to multi-threading, where multiple threads can run concurrently. However, the key difference lies in the scheduler’s behavior: a multi-threaded scheduler is preemptive, meaning it can stop a thread at any time, whereas an async scheduler can only regain control when an await is encountered. As a result, the code between awaits runs uninterrupted. In a sense, multi-threading can be thought of as an “always-on” async-await model, where the scheduler is constantly present between every statement or expression.</p>
<p>Here is a simple example using Rust’s Tokio async runtime:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">aa</span> = task::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">async</span> &#123; <span class="hljs-title function_ invoke__">asFunc</span>().<span class="hljs-keyword">await</span> &#125;);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">bb</span> = task::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">async</span> &#123;<br>        <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;before 1000&quot;</span>);<br>        <span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1000</span>)).<span class="hljs-keyword">await</span>;<br>        <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;1000&quot;</span>);<br>    &#125;);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">cc</span> = task::<span class="hljs-title function_ invoke__">spawn</span>(<span class="hljs-keyword">async</span> &#123;<br>        <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;before 1&quot;</span>);<br>        <span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">1</span>)).<span class="hljs-keyword">await</span>;<br>        <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Hello, world!&quot;</span>);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Bye, world!&quot;</span>);<br>    bb.<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">unwrap</span>();<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">asFunc</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;async&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">dd</span> = fs::<span class="hljs-title function_ invoke__">read_to_string</span>(<span class="hljs-string">&quot;Cargo.toml&quot;</span>).<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;out &#123;&#125;&quot;</span>, dd);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Let’s interpret the output:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs text">Hello, world!<br>Bye, world!<br>before 1000async<br>before 1out [package]<br>name = &quot;rusty&quot;<br>version = &quot;0.1.0&quot;<br>edition = &quot;2021&quot;<br><br>[[bin]]<br>path = &quot;src/main2.rs&quot;<br>name = &quot;alltuples&quot;<br><br>[dependencies]<br>tokio = &#123; version = &quot;1.40.0&quot;, features = [&quot;full&quot;] &#125;<br><br>11000<br></code></pre></td></tr></table></figure>

<p>In this example, we spawn three tasks (aa, bb, cc). Along with the main function, the async pool contains four tasks in total.</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">Main<br>aa<br>bb<br>cc<br></code></pre></td></tr></table></figure>

<p>When the first .await is encountered, control returns to the Tokio scheduler, which polls the bb task. When bb reaches its own await, control is yielded back to the scheduler. This explains why the line before 1000 appears before any other output from the tasks.</p>
<p>The scheduler then looks for other tasks that are ready to run. Since the main task is awaiting bb, both aa and cc are ready. The scheduler runs aa, printing “async”, then cc prints “before 1”. The remaining output comes from the continuation of these tasks.</p>
<h2 id="JS-async-vs-Rust-async"><a href="#JS-async-vs-Rust-async" class="headerlink" title="JS async vs Rust async"></a>JS async vs Rust async</h2><p>JavaScript’s async-await model differs from Tokio’s in two significant ways:</p>
<h3 id="First-await-execution-timing"><a href="#First-await-execution-timing" class="headerlink" title="First await execution timing"></a>First await execution timing</h3><p>In JavaScript, an async function executes everything before the first await immediately upon being called, while in Rust, code before the first await is deferred until explicitly awaited. Consider this JavaScript example:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">main</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> aa = <span class="hljs-title function_">asFunc</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;main&#x27;</span>);<br>    <span class="hljs-keyword">await</span> aa;<br>&#125;;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">asFunc</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;async&#x27;</span>);<br>    <span class="hljs-keyword">const</span> dd = <span class="hljs-keyword">await</span> fs.<span class="hljs-title function_">readFile</span>(<span class="hljs-string">&#x27;a.cs&#x27;</span>, <span class="hljs-string">&#x27;ascii&#x27;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(dd);<br>&#125;;<br><br><span class="hljs-title function_">main</span>();<br></code></pre></td></tr></table></figure>

<p>The output is:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">async<br>main<br></code></pre></td></tr></table></figure>

<p>Here, async is printed first because the code before the first await in asFunc executes immediately. However, the equivalent Rust code:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">aa</span> = <span class="hljs-title function_ invoke__">asFunc</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;main&quot;</span>);<br>    aa.<span class="hljs-keyword">await</span>;<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">asFunc</span>() &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;async&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">dd</span> = fs::<span class="hljs-title function_ invoke__">read_to_string</span>(<span class="hljs-string">&quot;Cargo.toml&quot;</span>).<span class="hljs-keyword">await</span>.<span class="hljs-title function_ invoke__">unwrap</span>();<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, dd);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>produces this output:</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">main<br>async<br>[package]<br>name = &quot;rusty&quot;<br>version = &quot;0.1.0&quot;<br>edition = &quot;2021&quot;<br></code></pre></td></tr></table></figure>

<p>In Rust, the line “async” only executes after aa.await.</p>
<h3 id="Task-spawning"><a href="#Task-spawning" class="headerlink" title="Task spawning"></a>Task spawning</h3><p>In JavaScript, async functions are automatically added to the event loop as tasks, whereas in Rust, tasks must be manually spawned. This difference stems from JavaScript’s runtime environment, where many async functions are part of the standard library and insert tasks into the event loop automatically. In contrast, in Tokio, tasks need to be explicitly spawned using task::spawn.</p>

    </div>

</div>

        </main>
        <hr>
<footer class="site-footer">
    <div class="top-nav fit-content">
        © 2023-2025 Ji Wang |
        <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc/4.0/" style="padding-left: 5px;">
            Creative Commons Attribution License
        </a>
    </div>
    <div class="top-nav fit-content">
        <a target="_blank" rel="noopener" href="https://github.com/Wang-Ji20" class="footer-links"><img src="/asset/github.svg" alt="github"
                width="20" height="20"></a>
        <a href="mailto:jiwangcdi@gmail.com" class="footer-links"><img src="/asset/email.svg" alt="email" width="20"
                height="20"></a>
        <a target="_blank" rel="noopener" href="https://www.linkedin.com/in/%E9%9B%86-%E7%8E%8B-67b0b92a7/" class="footer-links"><img
                src="/asset/linkedin.svg" alt="linkedin" width="20" height="20"></a>
    </div>
</footer>

    </div>
</body>

</html>
